"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/lenis";
exports.ids = ["vendor-chunks/lenis"];
exports.modules = {

/***/ "(ssr)/./node_modules/lenis/dist/lenis-react.mjs":
/*!*************************************************!*\
  !*** ./node_modules/lenis/dist/lenis-react.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Lenis: () => (/* binding */ ReactLenis),\n/* harmony export */   ReactLenis: () => (/* binding */ ReactLenis),\n/* harmony export */   \"default\": () => (/* binding */ ReactLenis),\n/* harmony export */   useLenis: () => (/* binding */ useLenis)\n/* harmony export */ });\n/* harmony import */ var lenis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lenis */ \"(ssr)/./node_modules/lenis/dist/lenis.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ Lenis,ReactLenis,default,useLenis auto */ // packages/react/src/provider.tsx\n\n\n// packages/react/src/store.ts\n\nvar Store = class {\n    constructor(state){\n        this.listeners = [];\n        this.state = state;\n    }\n    set(state) {\n        this.state = state;\n        for (let listener of this.listeners){\n            listener(this.state);\n        }\n    }\n    subscribe(listener) {\n        this.listeners = [\n            ...this.listeners,\n            listener\n        ];\n        return ()=>{\n            this.listeners = this.listeners.filter((l)=>l !== listener);\n        };\n    }\n    get() {\n        return this.state;\n    }\n};\nfunction useStore(store) {\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(store.get());\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useStore.useEffect\": ()=>{\n            return store.subscribe({\n                \"useStore.useEffect\": (state2)=>setState(state2)\n            }[\"useStore.useEffect\"]);\n        }\n    }[\"useStore.useEffect\"], [\n        store\n    ]);\n    return state;\n}\n// packages/react/src/provider.tsx\n\nvar LenisContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar rootLenisContextStore = new Store(null);\nvar ReactLenis = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ children, root = false, options = {}, className, autoRaf = true, style, props }, ref)=>{\n    const wrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const contentRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [lenis, setLenis] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, {\n        \"ReactLenis.useImperativeHandle\": ()=>({\n                wrapper: wrapperRef.current,\n                content: contentRef.current,\n                lenis\n            })\n    }[\"ReactLenis.useImperativeHandle\"], [\n        lenis\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ReactLenis.useEffect2\": ()=>{\n            const lenis2 = new lenis__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                ...options,\n                ...!root && {\n                    wrapper: wrapperRef.current,\n                    content: contentRef.current\n                },\n                autoRaf: options?.autoRaf ?? autoRaf\n            });\n            setLenis(lenis2);\n            return ({\n                \"ReactLenis.useEffect2\": ()=>{\n                    lenis2.destroy();\n                    setLenis(void 0);\n                }\n            })[\"ReactLenis.useEffect2\"];\n        }\n    }[\"ReactLenis.useEffect2\"], [\n        root,\n        JSON.stringify(options)\n    ]);\n    const callbacksRefs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const addCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"ReactLenis.useCallback[addCallback]\": (callback, priority)=>{\n            callbacksRefs.current.push({\n                callback,\n                priority\n            });\n            callbacksRefs.current.sort({\n                \"ReactLenis.useCallback[addCallback]\": (a, b)=>a.priority - b.priority\n            }[\"ReactLenis.useCallback[addCallback]\"]);\n        }\n    }[\"ReactLenis.useCallback[addCallback]\"], []);\n    const removeCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"ReactLenis.useCallback[removeCallback]\": (callback)=>{\n            callbacksRefs.current = callbacksRefs.current.filter({\n                \"ReactLenis.useCallback[removeCallback]\": (cb)=>cb.callback !== callback\n            }[\"ReactLenis.useCallback[removeCallback]\"]);\n        }\n    }[\"ReactLenis.useCallback[removeCallback]\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ReactLenis.useEffect2\": ()=>{\n            if (root && lenis) {\n                rootLenisContextStore.set({\n                    lenis,\n                    addCallback,\n                    removeCallback\n                });\n                return ({\n                    \"ReactLenis.useEffect2\": ()=>rootLenisContextStore.set(null)\n                })[\"ReactLenis.useEffect2\"];\n            }\n        }\n    }[\"ReactLenis.useEffect2\"], [\n        root,\n        lenis,\n        addCallback,\n        removeCallback\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"ReactLenis.useEffect2\": ()=>{\n            if (!lenis) return;\n            const onScroll = {\n                \"ReactLenis.useEffect2.onScroll\": (data)=>{\n                    for(let i = 0; i < callbacksRefs.current.length; i++){\n                        callbacksRefs.current[i]?.callback(data);\n                    }\n                }\n            }[\"ReactLenis.useEffect2.onScroll\"];\n            lenis.on(\"scroll\", onScroll);\n            return ({\n                \"ReactLenis.useEffect2\": ()=>{\n                    lenis.off(\"scroll\", onScroll);\n                }\n            })[\"ReactLenis.useEffect2\"];\n        }\n    }[\"ReactLenis.useEffect2\"], [\n        lenis\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LenisContext.Provider, {\n        value: {\n            lenis,\n            addCallback,\n            removeCallback\n        },\n        children: root ? children : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n            ref: wrapperRef,\n            className,\n            style,\n            ...props,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n                ref: contentRef,\n                children\n            })\n        })\n    });\n});\n// packages/react/src/use-lenis.ts\n\nvar fallbackContext = {};\nfunction useLenis(callback, deps = [], priority = 0) {\n    const localContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LenisContext);\n    const rootContext = useStore(rootLenisContextStore);\n    const currentContext = localContext ?? rootContext ?? fallbackContext;\n    const { lenis, addCallback, removeCallback } = currentContext;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useLenis.useEffect3\": ()=>{\n            if (!callback || !addCallback || !removeCallback || !lenis) return;\n            addCallback(callback, priority);\n            callback(lenis);\n            return ({\n                \"useLenis.useEffect3\": ()=>{\n                    removeCallback(callback);\n                }\n            })[\"useLenis.useEffect3\"];\n        }\n    }[\"useLenis.useEffect3\"], [\n        lenis,\n        addCallback,\n        removeCallback,\n        priority,\n        ...deps\n    ]);\n    return lenis;\n}\n //# sourceMappingURL=lenis-react.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGVuaXMvZGlzdC9sZW5pcy1yZWFjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBMkM7QUFTcEM7O0FDVDZCO0FBSTdCLElBQU0sUUFBTixNQUFlO0lBR3BCLFlBQW9CLE1BQVU7YUFGdEIsWUFBMkIsQ0FBQztRQUVoQjtJQUFXO0lBRS9CLElBQUksT0FBVTtRQUNaLEtBQUssUUFBUTtRQUViLFNBQVMsWUFBWSxLQUFLLFVBQVc7WUFDbkMsU0FBUyxLQUFLLEtBQUs7UUFDckI7SUFDRjtJQUVBLFVBQVUsVUFBdUI7UUFDL0IsS0FBSyxZQUFZLENBQUM7ZUFBRyxLQUFLO1lBQVcsUUFBUTtTQUFBO1FBQzdDLE9BQU87WUFDTCxLQUFLLFlBQVksS0FBSyxVQUFVLE9BQU8sQ0FBQyxJQUFNLE1BQU0sUUFBUTtRQUM5RDtJQUNGO0lBRUEsTUFBTTtRQUNKLE9BQU8sS0FBSztJQUNkO0FBQ0Y7QUFFTyxTQUFTLFNBQVksT0FBaUI7SUFDM0MsTUFBTSxDQUFDLE9BQU8sUUFBUSxJQUFJLCtDQUFRLENBQUMsTUFBTSxJQUFJLENBQUM7SUFFOUMsZ0RBQVM7OEJBQUM7WUFDUixPQUFPLE1BQU07c0NBQVUsQ0FBQ0UsU0FBVSxTQUFTQSxNQUFLLENBQUM7O1FBQ25EOzZCQUFHO1FBQUMsS0FBSztLQUFDO0lBRVYsT0FBTztBQUNUOztBRGdHWTtBQXhITCxJQUFNLDZCQUFlLG9EQUFhLENBQTJCLElBQUk7QUFRakUsSUFBTSx3QkFBd0IsSUFBSSxNQUFnQyxJQUFJO0FBS3RFLElBQU0sMkJBQWEsaURBQVUsQ0FDbEMsQ0FDRSxFQUNFLFVBQ0EsT0FBTyxPQUNQLFVBQVUsQ0FBQyxHQUNYLFdBQ0EsVUFBVSxNQUNWLE9BQ0EsT0FDRixFQUNBO0lBRUEsTUFBTSxhQUFhLDZDQUFNLENBQXdCLElBQUk7SUFDckQsTUFBTSxhQUFhLDZDQUFNLENBQXdCLElBQUk7SUFFckQsTUFBTSxDQUFDLE9BQU8sUUFBUSxJQUFJQywrQ0FBQUYsQ0FBNEIsTUFBUztJQUcvRCwwREFBbUIsQ0FDakI7MENBQ0EsS0FBTztnQkFDTCxTQUFTLFdBQVc7Z0JBQ3BCLFNBQVMsV0FBVztnQkFDcEI7YUFDRjt5Q0FDQTtRQUFDLEtBQUs7S0FBQTtJQUlSLGdEQUFBRDtpQ0FBVTtZQUNSLE1BQU1HLFNBQVEsSUFBSSw2Q0FBSyxDQUFDO2dCQUN0QixHQUFHO2dCQUNILEdBQUksQ0FBQyxRQUFRO29CQUNYLFNBQVMsV0FBVztvQkFDcEIsU0FBUyxXQUFXO2dCQUN0QjtnQkFDQSxTQUFTLFNBQVMsV0FBVztZQUMvQixDQUFDO1lBRUQsU0FBU0EsTUFBSztZQUVkO3lDQUFPO29CQUNMQSxPQUFNLFFBQVE7b0JBQ2QsU0FBUyxNQUFTO2dCQUNwQjs7UUFDRjtnQ0FBRztRQUFDO1FBQU0sS0FBSyxVQUFVLE9BQU8sQ0FBQztLQUFDO0lBR2xDLE1BQU0sZ0JBQWdCLDZDQUFNLENBSzFCLENBQUMsQ0FBQztJQUVKLE1BQU0sY0FBZ0Qsa0RBQVc7K0NBQy9ELENBQUMsVUFBVTtZQUNULGNBQWMsUUFBUSxLQUFLO2dCQUFFO2dCQUFVO1lBQVMsQ0FBQztZQUNqRCxjQUFjLFFBQVE7dURBQUssQ0FBQyxHQUFHLElBQU0sRUFBRSxXQUFXLEVBQUUsUUFBUTs7UUFDOUQ7OENBQ0EsQ0FBQztJQUdILE1BQU0saUJBQXNELGtEQUFXO2tEQUNyRSxDQUFDO1lBQ0MsY0FBYyxVQUFVLGNBQWMsUUFBUTswREFDNUMsQ0FBQyxLQUFPLEdBQUcsYUFBYTs7UUFFNUI7aURBQ0EsQ0FBQztJQUlILGdEQUFBSDtpQ0FBVTtZQUNSLElBQUksUUFBUSxPQUFPO2dCQUNqQixzQkFBc0IsSUFBSTtvQkFBRTtvQkFBTztvQkFBYTtnQkFBZSxDQUFDO2dCQUVoRTs2Q0FBTyxJQUFNLHNCQUFzQixJQUFJLElBQUk7O1lBQzdDO1FBQ0Y7Z0NBQUc7UUFBQztRQUFNO1FBQU87UUFBYSxjQUFjO0tBQUM7SUFHN0MsZ0RBQUFBO2lDQUFVO1lBQ1IsSUFBSSxDQUFDLE1BQU87WUFFWixNQUFNO2tEQUEyQixDQUFDO29CQUNoQyxRQUFTLElBQUksR0FBRyxJQUFJLGNBQWMsUUFBUSxRQUFRLElBQUs7d0JBQ3JELGNBQWMsUUFBUSxDQUFDLEdBQUcsU0FBUyxJQUFJO29CQUN6QztnQkFDRjs7WUFFQSxNQUFNLEdBQUcsVUFBVSxRQUFRO1lBRTNCO3lDQUFPO29CQUNMLE1BQU0sSUFBSSxVQUFVLFFBQVE7Z0JBQzlCOztRQUNGO2dDQUFHO1FBQUMsS0FBSztLQUFDO0lBRVYsT0FDRSx1RUFBQyxhQUFhLFVBQWI7UUFDQyxPQUFPO1lBQUU7WUFBZTtZQUFhO1FBQWU7UUFFbkQsaUJBQ0MsV0FFQSx1RUFBQztZQUFJLEtBQUs7WUFBWTtZQUFzQjtZQUFlLEdBQUc7WUFDNUQsaUZBQUM7Z0JBQUksS0FBSztnQkFBYTtZQUFBLENBQVM7UUFBQSxDQUNsQztJQUFBO0FBSVI7O0FFeklvQztBQU10QyxJQUFNLGtCQUE4QyxDQUFDO0FBMEM5QyxTQUFTLFNBQ2QsVUFDQSxPQUFjLENBQUMsR0FDZixXQUFXLEdBQ1g7SUFFQSxNQUFNLGVBQWUsaURBQVUsQ0FBQyxZQUFZO0lBRTVDLE1BQU0sY0FBYyxTQUFTLHFCQUFxQjtJQUVsRCxNQUFNLGlCQUFpQixnQkFBZ0IsZUFBZTtJQUV0RCxNQUFNLEVBQUUsT0FBTyxhQUFhLGVBQWUsSUFBSTtJQUUvQyxnREFBQUE7K0JBQVU7WUFDUixJQUFJLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFPO1lBRTVELFlBQVksVUFBVSxRQUFRO1lBQzlCLFNBQVMsS0FBSztZQUVkO3VDQUFPO29CQUNMLGVBQWUsUUFBUTtnQkFDekI7O1FBQ0Y7OEJBQUc7UUFBQztRQUFPO1FBQWE7UUFBZ0I7V0FBYSxJQUFJO0tBQUM7SUFFMUQsT0FBTztBQUNUIiwic291cmNlcyI6WyIvaG9tZS9hZHJqYW5vei9wYWNrYWdlcy9yZWFjdC9zcmMvcHJvdmlkZXIudHN4IiwiL2hvbWUvYWRyamFub3ovcGFja2FnZXMvcmVhY3Qvc3JjL3N0b3JlLnRzIiwiL2hvbWUvYWRyamFub3ovcGFja2FnZXMvcmVhY3Qvc3JjL3VzZS1sZW5pcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTGVuaXMsIHsgdHlwZSBTY3JvbGxDYWxsYmFjayB9IGZyb20gJ2xlbmlzJ1xyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZUNvbnRleHQsXHJcbiAgZm9yd2FyZFJlZixcclxuICB1c2VDYWxsYmFjayxcclxuICB1c2VFZmZlY3QsXHJcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSxcclxuICB1c2VSZWYsXHJcbiAgdXNlU3RhdGUsXHJcbn0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSAnLi9zdG9yZSdcclxuaW1wb3J0IHR5cGUgeyBMZW5pc0NvbnRleHRWYWx1ZSwgTGVuaXNQcm9wcywgTGVuaXNSZWYgfSBmcm9tICcuL3R5cGVzJ1xyXG5cclxuZXhwb3J0IGNvbnN0IExlbmlzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8TGVuaXNDb250ZXh0VmFsdWUgfCBudWxsPihudWxsKVxyXG5cclxuLyoqXHJcbiAqIFRoZSByb290IHN0b3JlIGZvciB0aGUgbGVuaXMgY29udGV4dFxyXG4gKlxyXG4gKiBUaGlzIHN0b3JlIHNlcnZlcyBhcyBhIGZhbGxiYWNrIGZvciB0aGUgY29udGV4dCBpZiBpdCBpcyBub3QgYXZhaWxhYmxlXHJcbiAqIGFuZCBhbGxvd3MgdXMgdG8gdXNlIHRoZSBnbG9iYWwgbGVuaXMgaW5zdGFuY2UgYWJvdmUgYSBwcm92aWRlclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHJvb3RMZW5pc0NvbnRleHRTdG9yZSA9IG5ldyBTdG9yZTxMZW5pc0NvbnRleHRWYWx1ZSB8IG51bGw+KG51bGwpXHJcblxyXG4vKipcclxuICogUmVhY3QgY29tcG9uZW50IHRvIHNldHVwIGEgTGVuaXMgaW5zdGFuY2VcclxuICovXHJcbmV4cG9ydCBjb25zdCBSZWFjdExlbmlzID0gZm9yd2FyZFJlZjxMZW5pc1JlZiwgTGVuaXNQcm9wcz4oXHJcbiAgKFxyXG4gICAge1xyXG4gICAgICBjaGlsZHJlbixcclxuICAgICAgcm9vdCA9IGZhbHNlLFxyXG4gICAgICBvcHRpb25zID0ge30sXHJcbiAgICAgIGNsYXNzTmFtZSxcclxuICAgICAgYXV0b1JhZiA9IHRydWUsXHJcbiAgICAgIHN0eWxlLFxyXG4gICAgICBwcm9wcyxcclxuICAgIH06IExlbmlzUHJvcHMsXHJcbiAgICByZWZcclxuICApID0+IHtcclxuICAgIGNvbnN0IHdyYXBwZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQgfCBudWxsPihudWxsKVxyXG4gICAgY29uc3QgY29udGVudFJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudCB8IG51bGw+KG51bGwpXHJcblxyXG4gICAgY29uc3QgW2xlbmlzLCBzZXRMZW5pc10gPSB1c2VTdGF0ZTxMZW5pcyB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKVxyXG5cclxuICAgIC8vIFNldHVwIHJlZlxyXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShcclxuICAgICAgcmVmLFxyXG4gICAgICAoKSA9PiAoe1xyXG4gICAgICAgIHdyYXBwZXI6IHdyYXBwZXJSZWYuY3VycmVudCxcclxuICAgICAgICBjb250ZW50OiBjb250ZW50UmVmLmN1cnJlbnQsXHJcbiAgICAgICAgbGVuaXMsXHJcbiAgICAgIH0pLFxyXG4gICAgICBbbGVuaXNdXHJcbiAgICApXHJcblxyXG4gICAgLy8gU2V0dXAgbGVuaXMgaW5zdGFuY2VcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGxlbmlzID0gbmV3IExlbmlzKHtcclxuICAgICAgICAuLi5vcHRpb25zLFxyXG4gICAgICAgIC4uLighcm9vdCAmJiB7XHJcbiAgICAgICAgICB3cmFwcGVyOiB3cmFwcGVyUmVmLmN1cnJlbnQhLFxyXG4gICAgICAgICAgY29udGVudDogY29udGVudFJlZi5jdXJyZW50ISxcclxuICAgICAgICB9KSxcclxuICAgICAgICBhdXRvUmFmOiBvcHRpb25zPy5hdXRvUmFmID8/IGF1dG9SYWYsIC8vIHRoaXMgaXMgdG8gYXZvaWQgYnJlYWtpbmcgdGhlIGF1dG9SYWYgcHJvcCBpZiBpdCdzIHN0aWxsIHVzZWQgKHJlcXVpcmUgYnJlYWtpbmcgY2hhbmdlKVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgc2V0TGVuaXMobGVuaXMpXHJcblxyXG4gICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGxlbmlzLmRlc3Ryb3koKVxyXG4gICAgICAgIHNldExlbmlzKHVuZGVmaW5lZClcclxuICAgICAgfVxyXG4gICAgfSwgW3Jvb3QsIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpXSlcclxuXHJcbiAgICAvLyBIYW5kbGUgY2FsbGJhY2tzXHJcbiAgICBjb25zdCBjYWxsYmFja3NSZWZzID0gdXNlUmVmPFxyXG4gICAgICB7XHJcbiAgICAgICAgY2FsbGJhY2s6IFNjcm9sbENhbGxiYWNrXHJcbiAgICAgICAgcHJpb3JpdHk6IG51bWJlclxyXG4gICAgICB9W11cclxuICAgID4oW10pXHJcblxyXG4gICAgY29uc3QgYWRkQ2FsbGJhY2s6IExlbmlzQ29udGV4dFZhbHVlWydhZGRDYWxsYmFjayddID0gdXNlQ2FsbGJhY2soXHJcbiAgICAgIChjYWxsYmFjaywgcHJpb3JpdHkpID0+IHtcclxuICAgICAgICBjYWxsYmFja3NSZWZzLmN1cnJlbnQucHVzaCh7IGNhbGxiYWNrLCBwcmlvcml0eSB9KVxyXG4gICAgICAgIGNhbGxiYWNrc1JlZnMuY3VycmVudC5zb3J0KChhLCBiKSA9PiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eSlcclxuICAgICAgfSxcclxuICAgICAgW11cclxuICAgIClcclxuXHJcbiAgICBjb25zdCByZW1vdmVDYWxsYmFjazogTGVuaXNDb250ZXh0VmFsdWVbJ3JlbW92ZUNhbGxiYWNrJ10gPSB1c2VDYWxsYmFjayhcclxuICAgICAgKGNhbGxiYWNrKSA9PiB7XHJcbiAgICAgICAgY2FsbGJhY2tzUmVmcy5jdXJyZW50ID0gY2FsbGJhY2tzUmVmcy5jdXJyZW50LmZpbHRlcihcclxuICAgICAgICAgIChjYikgPT4gY2IuY2FsbGJhY2sgIT09IGNhbGxiYWNrXHJcbiAgICAgICAgKVxyXG4gICAgICB9LFxyXG4gICAgICBbXVxyXG4gICAgKVxyXG5cclxuICAgIC8vIFRoaXMgbWFrZXMgc3VyZSB0byBzZXQgdGhlIGdsb2JhbCBjb250ZXh0IGlmIHRoZSByb290IGlzIHRydWVcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgIGlmIChyb290ICYmIGxlbmlzKSB7XHJcbiAgICAgICAgcm9vdExlbmlzQ29udGV4dFN0b3JlLnNldCh7IGxlbmlzLCBhZGRDYWxsYmFjaywgcmVtb3ZlQ2FsbGJhY2sgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHJvb3RMZW5pc0NvbnRleHRTdG9yZS5zZXQobnVsbClcclxuICAgICAgfVxyXG4gICAgfSwgW3Jvb3QsIGxlbmlzLCBhZGRDYWxsYmFjaywgcmVtb3ZlQ2FsbGJhY2tdKVxyXG5cclxuICAgIC8vIFNldHVwIGNhbGxiYWNrIGxpc3RlbmVyc1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgaWYgKCFsZW5pcykgcmV0dXJuXHJcblxyXG4gICAgICBjb25zdCBvblNjcm9sbDogU2Nyb2xsQ2FsbGJhY2sgPSAoZGF0YSkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzUmVmcy5jdXJyZW50Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjYWxsYmFja3NSZWZzLmN1cnJlbnRbaV0/LmNhbGxiYWNrKGRhdGEpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBsZW5pcy5vbignc2Nyb2xsJywgb25TY3JvbGwpXHJcblxyXG4gICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIGxlbmlzLm9mZignc2Nyb2xsJywgb25TY3JvbGwpXHJcbiAgICAgIH1cclxuICAgIH0sIFtsZW5pc10pXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgPExlbmlzQ29udGV4dC5Qcm92aWRlclxyXG4gICAgICAgIHZhbHVlPXt7IGxlbmlzOiBsZW5pcyEsIGFkZENhbGxiYWNrLCByZW1vdmVDYWxsYmFjayB9fVxyXG4gICAgICA+XHJcbiAgICAgICAge3Jvb3QgPyAoXHJcbiAgICAgICAgICBjaGlsZHJlblxyXG4gICAgICAgICkgOiAoXHJcbiAgICAgICAgICA8ZGl2IHJlZj17d3JhcHBlclJlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWV9IHN0eWxlPXtzdHlsZX0gey4uLnByb3BzfT5cclxuICAgICAgICAgICAgPGRpdiByZWY9e2NvbnRlbnRSZWZ9PntjaGlsZHJlbn08L2Rpdj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICl9XHJcbiAgICAgIDwvTGVuaXNDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKVxyXG4gIH1cclxuKVxyXG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXHJcblxyXG50eXBlIExpc3RlbmVyPFM+ID0gKHN0YXRlOiBTKSA9PiB2b2lkXHJcblxyXG5leHBvcnQgY2xhc3MgU3RvcmU8Uz4ge1xyXG4gIHByaXZhdGUgbGlzdGVuZXJzOiBMaXN0ZW5lcjxTPltdID0gW11cclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzdGF0ZTogUykge31cclxuXHJcbiAgc2V0KHN0YXRlOiBTKSB7XHJcbiAgICB0aGlzLnN0YXRlID0gc3RhdGVcclxuXHJcbiAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycykge1xyXG4gICAgICBsaXN0ZW5lcih0aGlzLnN0YXRlKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3Vic2NyaWJlKGxpc3RlbmVyOiBMaXN0ZW5lcjxTPikge1xyXG4gICAgdGhpcy5saXN0ZW5lcnMgPSBbLi4udGhpcy5saXN0ZW5lcnMsIGxpc3RlbmVyXVxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgdGhpcy5saXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycy5maWx0ZXIoKGwpID0+IGwgIT09IGxpc3RlbmVyKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdGVcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VTdG9yZTxTPihzdG9yZTogU3RvcmU8Uz4pIHtcclxuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlKHN0b3JlLmdldCgpKVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgcmV0dXJuIHN0b3JlLnN1YnNjcmliZSgoc3RhdGUpID0+IHNldFN0YXRlKHN0YXRlKSlcclxuICB9LCBbc3RvcmVdKVxyXG5cclxuICByZXR1cm4gc3RhdGVcclxufVxyXG4iLCJpbXBvcnQgdHlwZSB7IFNjcm9sbENhbGxiYWNrIH0gZnJvbSAnbGVuaXMnXHJcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xyXG5pbXBvcnQgeyBMZW5pc0NvbnRleHQsIHJvb3RMZW5pc0NvbnRleHRTdG9yZSB9IGZyb20gJy4vcHJvdmlkZXInXHJcbmltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnLi9zdG9yZSdcclxuaW1wb3J0IHR5cGUgeyBMZW5pc0NvbnRleHRWYWx1ZSB9IGZyb20gJy4vdHlwZXMnXHJcblxyXG4vLyBGYWxsIGJhY2sgdG8gYW4gZW1wdHkgb2JqZWN0IGlmIGJvdGggY29udGV4dCBhbmQgc3RvcmUgYXJlIG5vdCBhdmFpbGFibGVcclxuY29uc3QgZmFsbGJhY2tDb250ZXh0OiBQYXJ0aWFsPExlbmlzQ29udGV4dFZhbHVlPiA9IHt9XHJcblxyXG4vKipcclxuICogSG9vayB0byBhY2Nlc3MgdGhlIExlbmlzIGluc3RhbmNlIGFuZCBpdHMgbWV0aG9kc1xyXG4gKlxyXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5TY3JvbGwgY2FsbGJhY2s8L2NhcHRpb24+XHJcbiAqICAgICAgICAgIHVzZUxlbmlzKChsZW5pcykgPT4ge1xyXG4gKiAgICAgICAgICAgIGlmIChsZW5pcy5pc1Njcm9sbGluZykge1xyXG4gKiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1Njcm9sbGluZy4uLicpXHJcbiAqICAgICAgICAgICAgfVxyXG4gKlxyXG4gKiAgICAgICAgICAgIGlmIChsZW5pcy5wcm9ncmVzcyA9PT0gMSkge1xyXG4gKiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0F0IHRoZSBlbmQhJylcclxuICogICAgICAgICAgICB9XHJcbiAqICAgICAgICAgIH0pXHJcbiAqXHJcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlNjcm9sbCBjYWxsYmFjayB3aXRoIGRlcGVuZGVuY2llczwvY2FwdGlvbj5cclxuICogICAgICAgICAgdXNlTGVuaXMoKGxlbmlzKSA9PiB7XHJcbiAqICAgICAgICAgICAgaWYgKGxlbmlzLmlzU2Nyb2xsaW5nKSB7XHJcbiAqICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU2Nyb2xsaW5nLi4uJywgc29tZURlcGVuZGVuY3kpXHJcbiAqICAgICAgICAgICAgfVxyXG4gKiAgICAgICAgICB9LCBbc29tZURlcGVuZGVuY3ldKVxyXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5TY3JvbGwgY2FsbGJhY2sgd2l0aCBwcmlvcml0eTwvY2FwdGlvbj5cclxuICogICAgICAgICAgdXNlTGVuaXMoKGxlbmlzKSA9PiB7XHJcbiAqICAgICAgICAgICAgaWYgKGxlbmlzLmlzU2Nyb2xsaW5nKSB7XHJcbiAqICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU2Nyb2xsaW5nLi4uJylcclxuICogICAgICAgICAgICB9XHJcbiAqICAgICAgICAgIH0sIFtdLCAxKVxyXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5JbnN0YW5jZSBhY2Nlc3M8L2NhcHRpb24+XHJcbiAqICAgICAgICAgIGNvbnN0IGxlbmlzID0gdXNlTGVuaXMoKVxyXG4gKlxyXG4gKiAgICAgICAgICBoYW5kbGVDbGljaygpIHtcclxuICogICAgICAgICAgICBsZW5pcy5zY3JvbGxUbygxMDAsIHtcclxuICogICAgICAgICAgICAgIGxlcnA6IDAuMSxcclxuICogICAgICAgICAgICAgIGR1cmF0aW9uOiAxLFxyXG4gKiAgICAgICAgICAgICAgZWFzaW5nOiAodCkgPT4gdCxcclxuICogICAgICAgICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcclxuICogICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0NvbXBsZXRlIScpXHJcbiAqICAgICAgICAgICAgICB9XHJcbiAqICAgICAgICAgICAgfSlcclxuICogICAgICAgICAgfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxlbmlzKFxyXG4gIGNhbGxiYWNrPzogU2Nyb2xsQ2FsbGJhY2ssXHJcbiAgZGVwczogYW55W10gPSBbXSxcclxuICBwcmlvcml0eSA9IDBcclxuKSB7XHJcbiAgLy8gVHJ5IHRvIGdldCB0aGUgbGVuaXMgaW5zdGFuY2UgZnJvbSB0aGUgY29udGV4dCBmaXJzdFxyXG4gIGNvbnN0IGxvY2FsQ29udGV4dCA9IHVzZUNvbnRleHQoTGVuaXNDb250ZXh0KVxyXG4gIC8vIEZhbGwgYmFjayB0byB0aGUgcm9vdCBzdG9yZSBpZiB0aGUgY29udGV4dCBpcyBub3QgYXZhaWxhYmxlXHJcbiAgY29uc3Qgcm9vdENvbnRleHQgPSB1c2VTdG9yZShyb290TGVuaXNDb250ZXh0U3RvcmUpXHJcbiAgLy8gRmFsbCBiYWNrIHRvIHRoZSBmYWxsYmFjayBjb250ZXh0IGlmIGFsbCBlbHNlIGZhaWxzXHJcbiAgY29uc3QgY3VycmVudENvbnRleHQgPSBsb2NhbENvbnRleHQgPz8gcm9vdENvbnRleHQgPz8gZmFsbGJhY2tDb250ZXh0XHJcblxyXG4gIGNvbnN0IHsgbGVuaXMsIGFkZENhbGxiYWNrLCByZW1vdmVDYWxsYmFjayB9ID0gY3VycmVudENvbnRleHRcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghY2FsbGJhY2sgfHwgIWFkZENhbGxiYWNrIHx8ICFyZW1vdmVDYWxsYmFjayB8fCAhbGVuaXMpIHJldHVyblxyXG5cclxuICAgIGFkZENhbGxiYWNrKGNhbGxiYWNrLCBwcmlvcml0eSlcclxuICAgIGNhbGxiYWNrKGxlbmlzKVxyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHJlbW92ZUNhbGxiYWNrKGNhbGxiYWNrKVxyXG4gICAgfVxyXG4gIH0sIFtsZW5pcywgYWRkQ2FsbGJhY2ssIHJlbW92ZUNhbGxiYWNrLCBwcmlvcml0eSwgLi4uZGVwc10pXHJcblxyXG4gIHJldHVybiBsZW5pc1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInN0YXRlIiwibGVuaXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/lenis/dist/lenis-react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/lenis/dist/lenis.mjs":
/*!*******************************************!*\
  !*** ./node_modules/lenis/dist/lenis.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Lenis)\n/* harmony export */ });\n// package.json\nvar version = \"1.1.20\";\n\n// packages/core/src/maths.ts\nfunction clamp(min, input, max) {\n  return Math.max(min, Math.min(input, max));\n}\nfunction lerp(x, y, t) {\n  return (1 - t) * x + t * y;\n}\nfunction damp(x, y, lambda, deltaTime) {\n  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime));\n}\nfunction modulo(n, d) {\n  return (n % d + d) % d;\n}\n\n// packages/core/src/animate.ts\nvar Animate = class {\n  isRunning = false;\n  value = 0;\n  from = 0;\n  to = 0;\n  currentTime = 0;\n  // These are instanciated in the fromTo method\n  lerp;\n  duration;\n  easing;\n  onUpdate;\n  /**\n   * Advance the animation by the given delta time\n   *\n   * @param deltaTime - The time in seconds to advance the animation\n   */\n  advance(deltaTime) {\n    if (!this.isRunning) return;\n    let completed = false;\n    if (this.duration && this.easing) {\n      this.currentTime += deltaTime;\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1);\n      completed = linearProgress >= 1;\n      const easedProgress = completed ? 1 : this.easing(linearProgress);\n      this.value = this.from + (this.to - this.from) * easedProgress;\n    } else if (this.lerp) {\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime);\n      if (Math.round(this.value) === this.to) {\n        this.value = this.to;\n        completed = true;\n      }\n    } else {\n      this.value = this.to;\n      completed = true;\n    }\n    if (completed) {\n      this.stop();\n    }\n    this.onUpdate?.(this.value, completed);\n  }\n  /** Stop the animation */\n  stop() {\n    this.isRunning = false;\n  }\n  /**\n   * Set up the animation from a starting value to an ending value\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\n   *\n   * @param from - The starting value\n   * @param to - The ending value\n   * @param options - Options for the animation\n   */\n  fromTo(from, to, { lerp: lerp2, duration, easing, onStart, onUpdate }) {\n    this.from = this.value = from;\n    this.to = to;\n    this.lerp = lerp2;\n    this.duration = duration;\n    this.easing = easing;\n    this.currentTime = 0;\n    this.isRunning = true;\n    onStart?.();\n    this.onUpdate = onUpdate;\n  }\n};\n\n// packages/core/src/debounce.ts\nfunction debounce(callback, delay) {\n  let timer;\n  return function(...args) {\n    let context = this;\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      timer = void 0;\n      callback.apply(context, args);\n    }, delay);\n  };\n}\n\n// packages/core/src/dimensions.ts\nvar Dimensions = class {\n  constructor(wrapper, content, { autoResize = true, debounce: debounceValue = 250 } = {}) {\n    this.wrapper = wrapper;\n    this.content = content;\n    if (autoResize) {\n      this.debouncedResize = debounce(this.resize, debounceValue);\n      if (this.wrapper instanceof Window) {\n        window.addEventListener(\"resize\", this.debouncedResize, false);\n      } else {\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize);\n        this.wrapperResizeObserver.observe(this.wrapper);\n      }\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize);\n      this.contentResizeObserver.observe(this.content);\n    }\n    this.resize();\n  }\n  width = 0;\n  height = 0;\n  scrollHeight = 0;\n  scrollWidth = 0;\n  // These are instanciated in the constructor as they need information from the options\n  debouncedResize;\n  wrapperResizeObserver;\n  contentResizeObserver;\n  destroy() {\n    this.wrapperResizeObserver?.disconnect();\n    this.contentResizeObserver?.disconnect();\n    if (this.wrapper === window && this.debouncedResize) {\n      window.removeEventListener(\"resize\", this.debouncedResize, false);\n    }\n  }\n  resize = () => {\n    this.onWrapperResize();\n    this.onContentResize();\n  };\n  onWrapperResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.width = window.innerWidth;\n      this.height = window.innerHeight;\n    } else {\n      this.width = this.wrapper.clientWidth;\n      this.height = this.wrapper.clientHeight;\n    }\n  };\n  onContentResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.scrollHeight = this.content.scrollHeight;\n      this.scrollWidth = this.content.scrollWidth;\n    } else {\n      this.scrollHeight = this.wrapper.scrollHeight;\n      this.scrollWidth = this.wrapper.scrollWidth;\n    }\n  };\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height\n    };\n  }\n};\n\n// packages/core/src/emitter.ts\nvar Emitter = class {\n  events = {};\n  /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */\n  emit(event, ...args) {\n    let callbacks = this.events[event] || [];\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i]?.(...args);\n    }\n  }\n  /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */\n  on(event, cb) {\n    this.events[event]?.push(cb) || (this.events[event] = [cb]);\n    return () => {\n      this.events[event] = this.events[event]?.filter((i) => cb !== i);\n    };\n  }\n  /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off(event, callback) {\n    this.events[event] = this.events[event]?.filter((i) => callback !== i);\n  }\n  /**\n   * Remove all event listeners and clean up\n   */\n  destroy() {\n    this.events = {};\n  }\n};\n\n// packages/core/src/virtual-scroll.ts\nvar LINE_HEIGHT = 100 / 6;\nvar listenerOptions = { passive: false };\nvar VirtualScroll = class {\n  constructor(element, options = { wheelMultiplier: 1, touchMultiplier: 1 }) {\n    this.element = element;\n    this.options = options;\n    window.addEventListener(\"resize\", this.onWindowResize, false);\n    this.onWindowResize();\n    this.element.addEventListener(\"wheel\", this.onWheel, listenerOptions);\n    this.element.addEventListener(\n      \"touchstart\",\n      this.onTouchStart,\n      listenerOptions\n    );\n    this.element.addEventListener(\n      \"touchmove\",\n      this.onTouchMove,\n      listenerOptions\n    );\n    this.element.addEventListener(\"touchend\", this.onTouchEnd, listenerOptions);\n  }\n  touchStart = {\n    x: 0,\n    y: 0\n  };\n  lastDelta = {\n    x: 0,\n    y: 0\n  };\n  window = {\n    width: 0,\n    height: 0\n  };\n  emitter = new Emitter();\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  /** Remove all event listeners and clean up */\n  destroy() {\n    this.emitter.destroy();\n    window.removeEventListener(\"resize\", this.onWindowResize, false);\n    this.element.removeEventListener(\"wheel\", this.onWheel, listenerOptions);\n    this.element.removeEventListener(\n      \"touchstart\",\n      this.onTouchStart,\n      listenerOptions\n    );\n    this.element.removeEventListener(\n      \"touchmove\",\n      this.onTouchMove,\n      listenerOptions\n    );\n    this.element.removeEventListener(\n      \"touchend\",\n      this.onTouchEnd,\n      listenerOptions\n    );\n  }\n  /**\n   * Event handler for 'touchstart' event\n   *\n   * @param event Touch event\n   */\n  onTouchStart = (event) => {\n    const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n    this.touchStart.x = clientX;\n    this.touchStart.y = clientY;\n    this.lastDelta = {\n      x: 0,\n      y: 0\n    };\n    this.emitter.emit(\"scroll\", {\n      deltaX: 0,\n      deltaY: 0,\n      event\n    });\n  };\n  /** Event handler for 'touchmove' event */\n  onTouchMove = (event) => {\n    const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n    const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier;\n    const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier;\n    this.touchStart.x = clientX;\n    this.touchStart.y = clientY;\n    this.lastDelta = {\n      x: deltaX,\n      y: deltaY\n    };\n    this.emitter.emit(\"scroll\", {\n      deltaX,\n      deltaY,\n      event\n    });\n  };\n  onTouchEnd = (event) => {\n    this.emitter.emit(\"scroll\", {\n      deltaX: this.lastDelta.x,\n      deltaY: this.lastDelta.y,\n      event\n    });\n  };\n  /** Event handler for 'wheel' event */\n  onWheel = (event) => {\n    let { deltaX, deltaY, deltaMode } = event;\n    const multiplierX = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1;\n    const multiplierY = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1;\n    deltaX *= multiplierX;\n    deltaY *= multiplierY;\n    deltaX *= this.options.wheelMultiplier;\n    deltaY *= this.options.wheelMultiplier;\n    this.emitter.emit(\"scroll\", { deltaX, deltaY, event });\n  };\n  onWindowResize = () => {\n    this.window = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n  };\n};\n\n// packages/core/src/lenis.ts\nvar Lenis = class {\n  _isScrolling = false;\n  // true when scroll is animating\n  _isStopped = false;\n  // true if user should not be able to scroll - enable/disable programmatically\n  _isLocked = false;\n  // same as isStopped but enabled/disabled when scroll reaches target\n  _preventNextNativeScrollEvent = false;\n  _resetVelocityTimeout = null;\n  __rafID = null;\n  /**\n   * Whether or not the user is touching the screen\n   */\n  isTouching;\n  /**\n   * The time in ms since the lenis instance was created\n   */\n  time = 0;\n  /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: 'bar'\n   *   }\n   * })\n   */\n  userData = {};\n  /**\n   * The last velocity of the scroll\n   */\n  lastVelocity = 0;\n  /**\n   * The current velocity of the scroll\n   */\n  velocity = 0;\n  /**\n   * The direction of the scroll\n   */\n  direction = 0;\n  /**\n   * The options passed to the lenis instance\n   */\n  options;\n  /**\n   * The target scroll value\n   */\n  targetScroll;\n  /**\n   * The animated scroll value\n   */\n  animatedScroll;\n  // These are instanciated here as they don't need information from the options\n  animate = new Animate();\n  emitter = new Emitter();\n  // These are instanciated in the constructor as they need information from the options\n  dimensions;\n  // This is not private because it's used in the Snap class\n  virtualScroll;\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    eventsTarget = wrapper,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    touchInertiaMultiplier = 35,\n    duration,\n    // in seconds\n    easing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\n    lerp: lerp2 = 0.1,\n    infinite = false,\n    orientation = \"vertical\",\n    // vertical, horizontal\n    gestureOrientation = \"vertical\",\n    // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    autoResize = true,\n    prevent,\n    virtualScroll,\n    overscroll = true,\n    autoRaf = false,\n    anchors = false,\n    __experimental__naiveDimensions = false\n  } = {}) {\n    window.lenisVersion = version;\n    if (!wrapper || wrapper === document.documentElement) {\n      wrapper = window;\n    }\n    this.options = {\n      wrapper,\n      content,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaMultiplier,\n      duration,\n      easing,\n      lerp: lerp2,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      autoResize,\n      prevent,\n      virtualScroll,\n      overscroll,\n      autoRaf,\n      anchors,\n      __experimental__naiveDimensions\n    };\n    this.dimensions = new Dimensions(wrapper, content, { autoResize });\n    this.updateClassName();\n    this.targetScroll = this.animatedScroll = this.actualScroll;\n    this.options.wrapper.addEventListener(\"scroll\", this.onNativeScroll, false);\n    this.options.wrapper.addEventListener(\"scrollend\", this.onScrollEnd, {\n      capture: true\n    });\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.addEventListener(\n        \"click\",\n        this.onClick,\n        false\n      );\n    }\n    this.options.wrapper.addEventListener(\n      \"pointerdown\",\n      this.onPointerDown,\n      false\n    );\n    this.virtualScroll = new VirtualScroll(eventsTarget, {\n      touchMultiplier,\n      wheelMultiplier\n    });\n    this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n    if (this.options.autoRaf) {\n      this.__rafID = requestAnimationFrame(this.raf);\n    }\n  }\n  /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */\n  destroy() {\n    this.emitter.destroy();\n    this.options.wrapper.removeEventListener(\n      \"scroll\",\n      this.onNativeScroll,\n      false\n    );\n    this.options.wrapper.removeEventListener(\"scrollend\", this.onScrollEnd, {\n      capture: true\n    });\n    this.options.wrapper.removeEventListener(\n      \"pointerdown\",\n      this.onPointerDown,\n      false\n    );\n    if (this.options.anchors && this.options.wrapper === window) {\n      this.options.wrapper.removeEventListener(\n        \"click\",\n        this.onClick,\n        false\n      );\n    }\n    this.virtualScroll.destroy();\n    this.dimensions.destroy();\n    this.cleanUpClassName();\n    if (this.__rafID) {\n      cancelAnimationFrame(this.__rafID);\n    }\n  }\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  off(event, callback) {\n    return this.emitter.off(event, callback);\n  }\n  onScrollEnd = (e) => {\n    if (!(e instanceof CustomEvent)) {\n      if (this.isScrolling === \"smooth\" || this.isScrolling === false) {\n        e.stopPropagation();\n      }\n    }\n  };\n  dispatchScrollendEvent = () => {\n    this.options.wrapper.dispatchEvent(\n      new CustomEvent(\"scrollend\", {\n        bubbles: this.options.wrapper === window,\n        // cancelable: false,\n        detail: {\n          lenisScrollEnd: true\n        }\n      })\n    );\n  };\n  setScroll(scroll) {\n    if (this.isHorizontal) {\n      this.options.wrapper.scrollTo({ left: scroll, behavior: \"instant\" });\n    } else {\n      this.options.wrapper.scrollTo({ top: scroll, behavior: \"instant\" });\n    }\n  }\n  onClick = (event) => {\n    const path = event.composedPath();\n    const anchor = path.find(\n      (node) => node instanceof HTMLAnchorElement && node.getAttribute(\"href\")?.startsWith(\"#\")\n    );\n    if (anchor) {\n      const id = anchor.getAttribute(\"href\");\n      if (id) {\n        const options = typeof this.options.anchors === \"object\" && this.options.anchors ? this.options.anchors : void 0;\n        this.scrollTo(id, options);\n      }\n    }\n  };\n  onPointerDown = (event) => {\n    if (event.button === 1) {\n      this.reset();\n    }\n  };\n  onVirtualScroll = (data) => {\n    if (typeof this.options.virtualScroll === \"function\" && this.options.virtualScroll(data) === false)\n      return;\n    const { deltaX, deltaY, event } = data;\n    this.emitter.emit(\"virtual-scroll\", { deltaX, deltaY, event });\n    if (event.ctrlKey) return;\n    if (event.lenisStopPropagation) return;\n    const isTouch = event.type.includes(\"touch\");\n    const isWheel = event.type.includes(\"wheel\");\n    this.isTouching = event.type === \"touchstart\" || event.type === \"touchmove\";\n    const isClickOrTap = deltaX === 0 && deltaY === 0;\n    const isTapToStop = this.options.syncTouch && isTouch && event.type === \"touchstart\" && isClickOrTap && !this.isStopped && !this.isLocked;\n    if (isTapToStop) {\n      this.reset();\n      return;\n    }\n    const isUnknownGesture = this.options.gestureOrientation === \"vertical\" && deltaY === 0 || this.options.gestureOrientation === \"horizontal\" && deltaX === 0;\n    if (isClickOrTap || isUnknownGesture) {\n      return;\n    }\n    let composedPath = event.composedPath();\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement));\n    const prevent = this.options.prevent;\n    if (!!composedPath.find(\n      (node) => node instanceof HTMLElement && (typeof prevent === \"function\" && prevent?.(node) || node.hasAttribute?.(\"data-lenis-prevent\") || isTouch && node.hasAttribute?.(\"data-lenis-prevent-touch\") || isWheel && node.hasAttribute?.(\"data-lenis-prevent-wheel\"))\n    ))\n      return;\n    if (this.isStopped || this.isLocked) {\n      event.preventDefault();\n      return;\n    }\n    const isSmooth = this.options.syncTouch && isTouch || this.options.smoothWheel && isWheel;\n    if (!isSmooth) {\n      this.isScrolling = \"native\";\n      this.animate.stop();\n      event.lenisStopPropagation = true;\n      return;\n    }\n    let delta = deltaY;\n    if (this.options.gestureOrientation === \"both\") {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX;\n    } else if (this.options.gestureOrientation === \"horizontal\") {\n      delta = deltaX;\n    }\n    if (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && deltaY > 0 || this.animatedScroll === this.limit && deltaY < 0)) {\n      event.lenisStopPropagation = true;\n    }\n    event.preventDefault();\n    const isSyncTouch = isTouch && this.options.syncTouch;\n    const isTouchEnd = isTouch && event.type === \"touchend\";\n    const hasTouchInertia = isTouchEnd && Math.abs(delta) > 5;\n    if (hasTouchInertia) {\n      delta = this.velocity * this.options.touchInertiaMultiplier;\n    }\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...isSyncTouch ? {\n        lerp: hasTouchInertia ? this.options.syncTouchLerp : 1\n        // immediate: !hasTouchInertia,\n      } : {\n        lerp: this.options.lerp,\n        duration: this.options.duration,\n        easing: this.options.easing\n      }\n    });\n  };\n  /**\n   * Force lenis to recalculate the dimensions\n   */\n  resize() {\n    this.dimensions.resize();\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.emit();\n  }\n  emit() {\n    this.emitter.emit(\"scroll\", this);\n  }\n  onNativeScroll = () => {\n    if (this._resetVelocityTimeout !== null) {\n      clearTimeout(this._resetVelocityTimeout);\n      this._resetVelocityTimeout = null;\n    }\n    if (this._preventNextNativeScrollEvent) {\n      this._preventNextNativeScrollEvent = false;\n      return;\n    }\n    if (this.isScrolling === false || this.isScrolling === \"native\") {\n      const lastScroll = this.animatedScroll;\n      this.animatedScroll = this.targetScroll = this.actualScroll;\n      this.lastVelocity = this.velocity;\n      this.velocity = this.animatedScroll - lastScroll;\n      this.direction = Math.sign(\n        this.animatedScroll - lastScroll\n      );\n      if (!this.isStopped) {\n        this.isScrolling = \"native\";\n      }\n      this.emit();\n      if (this.velocity !== 0) {\n        this._resetVelocityTimeout = setTimeout(() => {\n          this.lastVelocity = this.velocity;\n          this.velocity = 0;\n          this.isScrolling = false;\n          this.emit();\n        }, 400);\n      }\n    }\n  };\n  reset() {\n    this.isLocked = false;\n    this.isScrolling = false;\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.lastVelocity = this.velocity = 0;\n    this.animate.stop();\n  }\n  /**\n   * Start lenis scroll after it has been stopped\n   */\n  start() {\n    if (!this.isStopped) return;\n    this.reset();\n    this.isStopped = false;\n  }\n  /**\n   * Stop lenis scroll\n   */\n  stop() {\n    if (this.isStopped) return;\n    this.reset();\n    this.isStopped = true;\n  }\n  /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */\n  raf = (time) => {\n    const deltaTime = time - (this.time || time);\n    this.time = time;\n    this.animate.advance(deltaTime * 1e-3);\n    if (this.options.autoRaf) {\n      this.__rafID = requestAnimationFrame(this.raf);\n    }\n  };\n  /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */\n  scrollTo(target, {\n    offset = 0,\n    immediate = false,\n    lock = false,\n    duration = this.options.duration,\n    easing = this.options.easing,\n    lerp: lerp2 = this.options.lerp,\n    onStart,\n    onComplete,\n    force = false,\n    // scroll even if stopped\n    programmatic = true,\n    // called from outside of the class\n    userData\n  } = {}) {\n    if ((this.isStopped || this.isLocked) && !force) return;\n    if (typeof target === \"string\" && [\"top\", \"left\", \"start\"].includes(target)) {\n      target = 0;\n    } else if (typeof target === \"string\" && [\"bottom\", \"right\", \"end\"].includes(target)) {\n      target = this.limit;\n    } else {\n      let node;\n      if (typeof target === \"string\") {\n        node = document.querySelector(target);\n      } else if (target instanceof HTMLElement && target?.nodeType) {\n        node = target;\n      }\n      if (node) {\n        if (this.options.wrapper !== window) {\n          const wrapperRect = this.rootElement.getBoundingClientRect();\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top;\n        }\n        const rect = node.getBoundingClientRect();\n        target = (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll;\n      }\n    }\n    if (typeof target !== \"number\") return;\n    target += offset;\n    target = Math.round(target);\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll;\n      }\n    } else {\n      target = clamp(0, target, this.limit);\n    }\n    if (target === this.targetScroll) {\n      onStart?.(this);\n      onComplete?.(this);\n      return;\n    }\n    this.userData = userData ?? {};\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target;\n      this.setScroll(this.scroll);\n      this.reset();\n      this.preventNextNativeScrollEvent();\n      this.emit();\n      onComplete?.(this);\n      this.userData = {};\n      requestAnimationFrame(() => {\n        this.dispatchScrollendEvent();\n      });\n      return;\n    }\n    if (!programmatic) {\n      this.targetScroll = target;\n    }\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp: lerp2,\n      onStart: () => {\n        if (lock) this.isLocked = true;\n        this.isScrolling = \"smooth\";\n        onStart?.(this);\n      },\n      onUpdate: (value, completed) => {\n        this.isScrolling = \"smooth\";\n        this.lastVelocity = this.velocity;\n        this.velocity = value - this.animatedScroll;\n        this.direction = Math.sign(this.velocity);\n        this.animatedScroll = value;\n        this.setScroll(this.scroll);\n        if (programmatic) {\n          this.targetScroll = value;\n        }\n        if (!completed) this.emit();\n        if (completed) {\n          this.reset();\n          this.emit();\n          onComplete?.(this);\n          this.userData = {};\n          requestAnimationFrame(() => {\n            this.dispatchScrollendEvent();\n          });\n          this.preventNextNativeScrollEvent();\n        }\n      }\n    });\n  }\n  preventNextNativeScrollEvent() {\n    this._preventNextNativeScrollEvent = true;\n    requestAnimationFrame(() => {\n      this._preventNextNativeScrollEvent = false;\n    });\n  }\n  /**\n   * The root element on which lenis is instanced\n   */\n  get rootElement() {\n    return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n  }\n  /**\n   * The limit which is the maximum scroll value\n   */\n  get limit() {\n    if (this.options.__experimental__naiveDimensions) {\n      if (this.isHorizontal) {\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth;\n      } else {\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight;\n      }\n    } else {\n      return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n    }\n  }\n  /**\n   * Whether or not the scroll is horizontal\n   */\n  get isHorizontal() {\n    return this.options.orientation === \"horizontal\";\n  }\n  /**\n   * The actual scroll value\n   */\n  get actualScroll() {\n    const wrapper = this.options.wrapper;\n    return this.isHorizontal ? wrapper.scrollX ?? wrapper.scrollLeft : wrapper.scrollY ?? wrapper.scrollTop;\n  }\n  /**\n   * The current scroll value\n   */\n  get scroll() {\n    return this.options.infinite ? modulo(this.animatedScroll, this.limit) : this.animatedScroll;\n  }\n  /**\n   * The progress of the scroll relative to the limit\n   */\n  get progress() {\n    return this.limit === 0 ? 1 : this.scroll / this.limit;\n  }\n  /**\n   * Current scroll state\n   */\n  get isScrolling() {\n    return this._isScrolling;\n  }\n  set isScrolling(value) {\n    if (this._isScrolling !== value) {\n      this._isScrolling = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is stopped\n   */\n  get isStopped() {\n    return this._isStopped;\n  }\n  set isStopped(value) {\n    if (this._isStopped !== value) {\n      this._isStopped = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is locked\n   */\n  get isLocked() {\n    return this._isLocked;\n  }\n  set isLocked(value) {\n    if (this._isLocked !== value) {\n      this._isLocked = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is smooth scrolling\n   */\n  get isSmooth() {\n    return this.isScrolling === \"smooth\";\n  }\n  /**\n   * The class name applied to the wrapper element\n   */\n  get className() {\n    let className = \"lenis\";\n    if (this.isStopped) className += \" lenis-stopped\";\n    if (this.isLocked) className += \" lenis-locked\";\n    if (this.isScrolling) className += \" lenis-scrolling\";\n    if (this.isScrolling === \"smooth\") className += \" lenis-smooth\";\n    return className;\n  }\n  updateClassName() {\n    this.cleanUpClassName();\n    this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim();\n  }\n  cleanUpClassName() {\n    this.rootElement.className = this.rootElement.className.replace(/lenis(-\\w+)?/g, \"\").trim();\n  }\n};\n\n//# sourceMappingURL=lenis.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGVuaXMvZGlzdC9sZW5pcy5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0RBQWtEO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxtREFBbUQsSUFBSTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxtQ0FBbUMsd0NBQXdDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0QkFBNEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHVCQUF1QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsWUFBWTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1DQUFtQztBQUN6RSxNQUFNO0FBQ04sc0NBQXNDLGtDQUFrQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEMsMENBQTBDLHVCQUF1QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDRCQUE0QixFQUFFLGVBQWU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9ob21lL2Fkcmphbm96L2Zsb3dmZXN0YXBwL25vZGVfbW9kdWxlcy9sZW5pcy9kaXN0L2xlbmlzLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBwYWNrYWdlLmpzb25cbnZhciB2ZXJzaW9uID0gXCIxLjEuMjBcIjtcblxuLy8gcGFja2FnZXMvY29yZS9zcmMvbWF0aHMudHNcbmZ1bmN0aW9uIGNsYW1wKG1pbiwgaW5wdXQsIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihpbnB1dCwgbWF4KSk7XG59XG5mdW5jdGlvbiBsZXJwKHgsIHksIHQpIHtcbiAgcmV0dXJuICgxIC0gdCkgKiB4ICsgdCAqIHk7XG59XG5mdW5jdGlvbiBkYW1wKHgsIHksIGxhbWJkYSwgZGVsdGFUaW1lKSB7XG4gIHJldHVybiBsZXJwKHgsIHksIDEgLSBNYXRoLmV4cCgtbGFtYmRhICogZGVsdGFUaW1lKSk7XG59XG5mdW5jdGlvbiBtb2R1bG8obiwgZCkge1xuICByZXR1cm4gKG4gJSBkICsgZCkgJSBkO1xufVxuXG4vLyBwYWNrYWdlcy9jb3JlL3NyYy9hbmltYXRlLnRzXG52YXIgQW5pbWF0ZSA9IGNsYXNzIHtcbiAgaXNSdW5uaW5nID0gZmFsc2U7XG4gIHZhbHVlID0gMDtcbiAgZnJvbSA9IDA7XG4gIHRvID0gMDtcbiAgY3VycmVudFRpbWUgPSAwO1xuICAvLyBUaGVzZSBhcmUgaW5zdGFuY2lhdGVkIGluIHRoZSBmcm9tVG8gbWV0aG9kXG4gIGxlcnA7XG4gIGR1cmF0aW9uO1xuICBlYXNpbmc7XG4gIG9uVXBkYXRlO1xuICAvKipcbiAgICogQWR2YW5jZSB0aGUgYW5pbWF0aW9uIGJ5IHRoZSBnaXZlbiBkZWx0YSB0aW1lXG4gICAqXG4gICAqIEBwYXJhbSBkZWx0YVRpbWUgLSBUaGUgdGltZSBpbiBzZWNvbmRzIHRvIGFkdmFuY2UgdGhlIGFuaW1hdGlvblxuICAgKi9cbiAgYWR2YW5jZShkZWx0YVRpbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG4gICAgbGV0IGNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmR1cmF0aW9uICYmIHRoaXMuZWFzaW5nKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lICs9IGRlbHRhVGltZTtcbiAgICAgIGNvbnN0IGxpbmVhclByb2dyZXNzID0gY2xhbXAoMCwgdGhpcy5jdXJyZW50VGltZSAvIHRoaXMuZHVyYXRpb24sIDEpO1xuICAgICAgY29tcGxldGVkID0gbGluZWFyUHJvZ3Jlc3MgPj0gMTtcbiAgICAgIGNvbnN0IGVhc2VkUHJvZ3Jlc3MgPSBjb21wbGV0ZWQgPyAxIDogdGhpcy5lYXNpbmcobGluZWFyUHJvZ3Jlc3MpO1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuZnJvbSArICh0aGlzLnRvIC0gdGhpcy5mcm9tKSAqIGVhc2VkUHJvZ3Jlc3M7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlcnApIHtcbiAgICAgIHRoaXMudmFsdWUgPSBkYW1wKHRoaXMudmFsdWUsIHRoaXMudG8sIHRoaXMubGVycCAqIDYwLCBkZWx0YVRpbWUpO1xuICAgICAgaWYgKE1hdGgucm91bmQodGhpcy52YWx1ZSkgPT09IHRoaXMudG8pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudG87XG4gICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnRvO1xuICAgICAgY29tcGxldGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNvbXBsZXRlZCkge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxuICAgIHRoaXMub25VcGRhdGU/Lih0aGlzLnZhbHVlLCBjb21wbGV0ZWQpO1xuICB9XG4gIC8qKiBTdG9wIHRoZSBhbmltYXRpb24gKi9cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdXAgdGhlIGFuaW1hdGlvbiBmcm9tIGEgc3RhcnRpbmcgdmFsdWUgdG8gYW4gZW5kaW5nIHZhbHVlXG4gICAqIHdpdGggb3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgbGVycGluZywgZHVyYXRpb24sIGVhc2luZywgYW5kIG9uVXBkYXRlIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIHN0YXJ0aW5nIHZhbHVlXG4gICAqIEBwYXJhbSB0byAtIFRoZSBlbmRpbmcgdmFsdWVcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgYW5pbWF0aW9uXG4gICAqL1xuICBmcm9tVG8oZnJvbSwgdG8sIHsgbGVycDogbGVycDIsIGR1cmF0aW9uLCBlYXNpbmcsIG9uU3RhcnQsIG9uVXBkYXRlIH0pIHtcbiAgICB0aGlzLmZyb20gPSB0aGlzLnZhbHVlID0gZnJvbTtcbiAgICB0aGlzLnRvID0gdG87XG4gICAgdGhpcy5sZXJwID0gbGVycDI7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuZWFzaW5nID0gZWFzaW5nO1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICBvblN0YXJ0Py4oKTtcbiAgICB0aGlzLm9uVXBkYXRlID0gb25VcGRhdGU7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2NvcmUvc3JjL2RlYm91bmNlLnRzXG5mdW5jdGlvbiBkZWJvdW5jZShjYWxsYmFjaywgZGVsYXkpIHtcbiAgbGV0IHRpbWVyO1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGxldCBjb250ZXh0ID0gdGhpcztcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aW1lciA9IHZvaWQgMDtcbiAgICAgIGNhbGxiYWNrLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH0sIGRlbGF5KTtcbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvY29yZS9zcmMvZGltZW5zaW9ucy50c1xudmFyIERpbWVuc2lvbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHdyYXBwZXIsIGNvbnRlbnQsIHsgYXV0b1Jlc2l6ZSA9IHRydWUsIGRlYm91bmNlOiBkZWJvdW5jZVZhbHVlID0gMjUwIH0gPSB7fSkge1xuICAgIHRoaXMud3JhcHBlciA9IHdyYXBwZXI7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICBpZiAoYXV0b1Jlc2l6ZSkge1xuICAgICAgdGhpcy5kZWJvdW5jZWRSZXNpemUgPSBkZWJvdW5jZSh0aGlzLnJlc2l6ZSwgZGVib3VuY2VWYWx1ZSk7XG4gICAgICBpZiAodGhpcy53cmFwcGVyIGluc3RhbmNlb2YgV2luZG93KSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuZGVib3VuY2VkUmVzaXplLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndyYXBwZXJSZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcih0aGlzLmRlYm91bmNlZFJlc2l6ZSk7XG4gICAgICAgIHRoaXMud3JhcHBlclJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy53cmFwcGVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGVudFJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHRoaXMuZGVib3VuY2VkUmVzaXplKTtcbiAgICAgIHRoaXMuY29udGVudFJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5jb250ZW50KTtcbiAgICB9XG4gICAgdGhpcy5yZXNpemUoKTtcbiAgfVxuICB3aWR0aCA9IDA7XG4gIGhlaWdodCA9IDA7XG4gIHNjcm9sbEhlaWdodCA9IDA7XG4gIHNjcm9sbFdpZHRoID0gMDtcbiAgLy8gVGhlc2UgYXJlIGluc3RhbmNpYXRlZCBpbiB0aGUgY29uc3RydWN0b3IgYXMgdGhleSBuZWVkIGluZm9ybWF0aW9uIGZyb20gdGhlIG9wdGlvbnNcbiAgZGVib3VuY2VkUmVzaXplO1xuICB3cmFwcGVyUmVzaXplT2JzZXJ2ZXI7XG4gIGNvbnRlbnRSZXNpemVPYnNlcnZlcjtcbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLndyYXBwZXJSZXNpemVPYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuY29udGVudFJlc2l6ZU9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgaWYgKHRoaXMud3JhcHBlciA9PT0gd2luZG93ICYmIHRoaXMuZGVib3VuY2VkUmVzaXplKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLmRlYm91bmNlZFJlc2l6ZSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXNpemUgPSAoKSA9PiB7XG4gICAgdGhpcy5vbldyYXBwZXJSZXNpemUoKTtcbiAgICB0aGlzLm9uQ29udGVudFJlc2l6ZSgpO1xuICB9O1xuICBvbldyYXBwZXJSZXNpemUgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMud3JhcHBlciBpbnN0YW5jZW9mIFdpbmRvdykge1xuICAgICAgdGhpcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLndyYXBwZXIuY2xpZW50V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMud3JhcHBlci5jbGllbnRIZWlnaHQ7XG4gICAgfVxuICB9O1xuICBvbkNvbnRlbnRSZXNpemUgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMud3JhcHBlciBpbnN0YW5jZW9mIFdpbmRvdykge1xuICAgICAgdGhpcy5zY3JvbGxIZWlnaHQgPSB0aGlzLmNvbnRlbnQuc2Nyb2xsSGVpZ2h0O1xuICAgICAgdGhpcy5zY3JvbGxXaWR0aCA9IHRoaXMuY29udGVudC5zY3JvbGxXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY3JvbGxIZWlnaHQgPSB0aGlzLndyYXBwZXIuc2Nyb2xsSGVpZ2h0O1xuICAgICAgdGhpcy5zY3JvbGxXaWR0aCA9IHRoaXMud3JhcHBlci5zY3JvbGxXaWR0aDtcbiAgICB9XG4gIH07XG4gIGdldCBsaW1pdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy5zY3JvbGxXaWR0aCAtIHRoaXMud2lkdGgsXG4gICAgICB5OiB0aGlzLnNjcm9sbEhlaWdodCAtIHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvY29yZS9zcmMvZW1pdHRlci50c1xudmFyIEVtaXR0ZXIgPSBjbGFzcyB7XG4gIGV2ZW50cyA9IHt9O1xuICAvKipcbiAgICogRW1pdCBhbiBldmVudCB3aXRoIHRoZSBnaXZlbiBkYXRhXG4gICAqIEBwYXJhbSBldmVudCBFdmVudCBuYW1lXG4gICAqIEBwYXJhbSBhcmdzIERhdGEgdG8gcGFzcyB0byB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICovXG4gIGVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICBsZXQgY2FsbGJhY2tzID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrc1tpXT8uKC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkIGEgY2FsbGJhY2sgdG8gdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBldmVudCBFdmVudCBuYW1lXG4gICAqIEBwYXJhbSBjYiBDYWxsYmFjayBmdW5jdGlvblxuICAgKiBAcmV0dXJucyBVbnN1YnNjcmliZSBmdW5jdGlvblxuICAgKi9cbiAgb24oZXZlbnQsIGNiKSB7XG4gICAgdGhpcy5ldmVudHNbZXZlbnRdPy5wdXNoKGNiKSB8fCAodGhpcy5ldmVudHNbZXZlbnRdID0gW2NiXSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzW2V2ZW50XSA9IHRoaXMuZXZlbnRzW2V2ZW50XT8uZmlsdGVyKChpKSA9PiBjYiAhPT0gaSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgZXZlbnRcbiAgICogQHBhcmFtIGV2ZW50IEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAqL1xuICBvZmYoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5ldmVudHNbZXZlbnRdID0gdGhpcy5ldmVudHNbZXZlbnRdPy5maWx0ZXIoKGkpID0+IGNhbGxiYWNrICE9PSBpKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnMgYW5kIGNsZWFuIHVwXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZXZlbnRzID0ge307XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2NvcmUvc3JjL3ZpcnR1YWwtc2Nyb2xsLnRzXG52YXIgTElORV9IRUlHSFQgPSAxMDAgLyA2O1xudmFyIGxpc3RlbmVyT3B0aW9ucyA9IHsgcGFzc2l2ZTogZmFsc2UgfTtcbnZhciBWaXJ0dWFsU2Nyb2xsID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zID0geyB3aGVlbE11bHRpcGxpZXI6IDEsIHRvdWNoTXVsdGlwbGllcjogMSB9KSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25XaW5kb3dSZXNpemUsIGZhbHNlKTtcbiAgICB0aGlzLm9uV2luZG93UmVzaXplKCk7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB0aGlzLm9uV2hlZWwsIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcInRvdWNoc3RhcnRcIixcbiAgICAgIHRoaXMub25Ub3VjaFN0YXJ0LFxuICAgICAgbGlzdGVuZXJPcHRpb25zXG4gICAgKTtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2htb3ZlXCIsXG4gICAgICB0aGlzLm9uVG91Y2hNb3ZlLFxuICAgICAgbGlzdGVuZXJPcHRpb25zXG4gICAgKTtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMub25Ub3VjaEVuZCwgbGlzdGVuZXJPcHRpb25zKTtcbiAgfVxuICB0b3VjaFN0YXJ0ID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICBsYXN0RGVsdGEgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG4gIHdpbmRvdyA9IHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfTtcbiAgZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gIC8qKlxuICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBnaXZlbiBldmVudCBhbmQgY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAqL1xuICBvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0dGVyLm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gIH1cbiAgLyoqIFJlbW92ZSBhbGwgZXZlbnQgbGlzdGVuZXJzIGFuZCBjbGVhbiB1cCAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZW1pdHRlci5kZXN0cm95KCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vbldpbmRvd1Jlc2l6ZSwgZmFsc2UpO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5vbldoZWVsLCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICB0aGlzLm9uVG91Y2hTdGFydCxcbiAgICAgIGxpc3RlbmVyT3B0aW9uc1xuICAgICk7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBcInRvdWNobW92ZVwiLFxuICAgICAgdGhpcy5vblRvdWNoTW92ZSxcbiAgICAgIGxpc3RlbmVyT3B0aW9uc1xuICAgICk7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBcInRvdWNoZW5kXCIsXG4gICAgICB0aGlzLm9uVG91Y2hFbmQsXG4gICAgICBsaXN0ZW5lck9wdGlvbnNcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciAndG91Y2hzdGFydCcgZXZlbnRcbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IFRvdWNoIGV2ZW50XG4gICAqL1xuICBvblRvdWNoU3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGV2ZW50LnRhcmdldFRvdWNoZXMgPyBldmVudC50YXJnZXRUb3VjaGVzWzBdIDogZXZlbnQ7XG4gICAgdGhpcy50b3VjaFN0YXJ0LnggPSBjbGllbnRYO1xuICAgIHRoaXMudG91Y2hTdGFydC55ID0gY2xpZW50WTtcbiAgICB0aGlzLmxhc3REZWx0YSA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdChcInNjcm9sbFwiLCB7XG4gICAgICBkZWx0YVg6IDAsXG4gICAgICBkZWx0YVk6IDAsXG4gICAgICBldmVudFxuICAgIH0pO1xuICB9O1xuICAvKiogRXZlbnQgaGFuZGxlciBmb3IgJ3RvdWNobW92ZScgZXZlbnQgKi9cbiAgb25Ub3VjaE1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGV2ZW50LnRhcmdldFRvdWNoZXMgPyBldmVudC50YXJnZXRUb3VjaGVzWzBdIDogZXZlbnQ7XG4gICAgY29uc3QgZGVsdGFYID0gLShjbGllbnRYIC0gdGhpcy50b3VjaFN0YXJ0LngpICogdGhpcy5vcHRpb25zLnRvdWNoTXVsdGlwbGllcjtcbiAgICBjb25zdCBkZWx0YVkgPSAtKGNsaWVudFkgLSB0aGlzLnRvdWNoU3RhcnQueSkgKiB0aGlzLm9wdGlvbnMudG91Y2hNdWx0aXBsaWVyO1xuICAgIHRoaXMudG91Y2hTdGFydC54ID0gY2xpZW50WDtcbiAgICB0aGlzLnRvdWNoU3RhcnQueSA9IGNsaWVudFk7XG4gICAgdGhpcy5sYXN0RGVsdGEgPSB7XG4gICAgICB4OiBkZWx0YVgsXG4gICAgICB5OiBkZWx0YVlcbiAgICB9O1xuICAgIHRoaXMuZW1pdHRlci5lbWl0KFwic2Nyb2xsXCIsIHtcbiAgICAgIGRlbHRhWCxcbiAgICAgIGRlbHRhWSxcbiAgICAgIGV2ZW50XG4gICAgfSk7XG4gIH07XG4gIG9uVG91Y2hFbmQgPSAoZXZlbnQpID0+IHtcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdChcInNjcm9sbFwiLCB7XG4gICAgICBkZWx0YVg6IHRoaXMubGFzdERlbHRhLngsXG4gICAgICBkZWx0YVk6IHRoaXMubGFzdERlbHRhLnksXG4gICAgICBldmVudFxuICAgIH0pO1xuICB9O1xuICAvKiogRXZlbnQgaGFuZGxlciBmb3IgJ3doZWVsJyBldmVudCAqL1xuICBvbldoZWVsID0gKGV2ZW50KSA9PiB7XG4gICAgbGV0IHsgZGVsdGFYLCBkZWx0YVksIGRlbHRhTW9kZSB9ID0gZXZlbnQ7XG4gICAgY29uc3QgbXVsdGlwbGllclggPSBkZWx0YU1vZGUgPT09IDEgPyBMSU5FX0hFSUdIVCA6IGRlbHRhTW9kZSA9PT0gMiA/IHRoaXMud2luZG93LndpZHRoIDogMTtcbiAgICBjb25zdCBtdWx0aXBsaWVyWSA9IGRlbHRhTW9kZSA9PT0gMSA/IExJTkVfSEVJR0hUIDogZGVsdGFNb2RlID09PSAyID8gdGhpcy53aW5kb3cuaGVpZ2h0IDogMTtcbiAgICBkZWx0YVggKj0gbXVsdGlwbGllclg7XG4gICAgZGVsdGFZICo9IG11bHRpcGxpZXJZO1xuICAgIGRlbHRhWCAqPSB0aGlzLm9wdGlvbnMud2hlZWxNdWx0aXBsaWVyO1xuICAgIGRlbHRhWSAqPSB0aGlzLm9wdGlvbnMud2hlZWxNdWx0aXBsaWVyO1xuICAgIHRoaXMuZW1pdHRlci5lbWl0KFwic2Nyb2xsXCIsIHsgZGVsdGFYLCBkZWx0YVksIGV2ZW50IH0pO1xuICB9O1xuICBvbldpbmRvd1Jlc2l6ZSA9ICgpID0+IHtcbiAgICB0aGlzLndpbmRvdyA9IHtcbiAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XG4gICAgfTtcbiAgfTtcbn07XG5cbi8vIHBhY2thZ2VzL2NvcmUvc3JjL2xlbmlzLnRzXG52YXIgTGVuaXMgPSBjbGFzcyB7XG4gIF9pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAvLyB0cnVlIHdoZW4gc2Nyb2xsIGlzIGFuaW1hdGluZ1xuICBfaXNTdG9wcGVkID0gZmFsc2U7XG4gIC8vIHRydWUgaWYgdXNlciBzaG91bGQgbm90IGJlIGFibGUgdG8gc2Nyb2xsIC0gZW5hYmxlL2Rpc2FibGUgcHJvZ3JhbW1hdGljYWxseVxuICBfaXNMb2NrZWQgPSBmYWxzZTtcbiAgLy8gc2FtZSBhcyBpc1N0b3BwZWQgYnV0IGVuYWJsZWQvZGlzYWJsZWQgd2hlbiBzY3JvbGwgcmVhY2hlcyB0YXJnZXRcbiAgX3ByZXZlbnROZXh0TmF0aXZlU2Nyb2xsRXZlbnQgPSBmYWxzZTtcbiAgX3Jlc2V0VmVsb2NpdHlUaW1lb3V0ID0gbnVsbDtcbiAgX19yYWZJRCA9IG51bGw7XG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgdXNlciBpcyB0b3VjaGluZyB0aGUgc2NyZWVuXG4gICAqL1xuICBpc1RvdWNoaW5nO1xuICAvKipcbiAgICogVGhlIHRpbWUgaW4gbXMgc2luY2UgdGhlIGxlbmlzIGluc3RhbmNlIHdhcyBjcmVhdGVkXG4gICAqL1xuICB0aW1lID0gMDtcbiAgLyoqXG4gICAqIFVzZXIgZGF0YSB0aGF0IHdpbGwgYmUgZm9yd2FyZGVkIHRocm91Z2ggdGhlIHNjcm9sbCBldmVudFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBsZW5pcy5zY3JvbGxUbygxMDAsIHtcbiAgICogICB1c2VyRGF0YToge1xuICAgKiAgICAgZm9vOiAnYmFyJ1xuICAgKiAgIH1cbiAgICogfSlcbiAgICovXG4gIHVzZXJEYXRhID0ge307XG4gIC8qKlxuICAgKiBUaGUgbGFzdCB2ZWxvY2l0eSBvZiB0aGUgc2Nyb2xsXG4gICAqL1xuICBsYXN0VmVsb2NpdHkgPSAwO1xuICAvKipcbiAgICogVGhlIGN1cnJlbnQgdmVsb2NpdHkgb2YgdGhlIHNjcm9sbFxuICAgKi9cbiAgdmVsb2NpdHkgPSAwO1xuICAvKipcbiAgICogVGhlIGRpcmVjdGlvbiBvZiB0aGUgc2Nyb2xsXG4gICAqL1xuICBkaXJlY3Rpb24gPSAwO1xuICAvKipcbiAgICogVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBsZW5pcyBpbnN0YW5jZVxuICAgKi9cbiAgb3B0aW9ucztcbiAgLyoqXG4gICAqIFRoZSB0YXJnZXQgc2Nyb2xsIHZhbHVlXG4gICAqL1xuICB0YXJnZXRTY3JvbGw7XG4gIC8qKlxuICAgKiBUaGUgYW5pbWF0ZWQgc2Nyb2xsIHZhbHVlXG4gICAqL1xuICBhbmltYXRlZFNjcm9sbDtcbiAgLy8gVGhlc2UgYXJlIGluc3RhbmNpYXRlZCBoZXJlIGFzIHRoZXkgZG9uJ3QgbmVlZCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBvcHRpb25zXG4gIGFuaW1hdGUgPSBuZXcgQW5pbWF0ZSgpO1xuICBlbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgLy8gVGhlc2UgYXJlIGluc3RhbmNpYXRlZCBpbiB0aGUgY29uc3RydWN0b3IgYXMgdGhleSBuZWVkIGluZm9ybWF0aW9uIGZyb20gdGhlIG9wdGlvbnNcbiAgZGltZW5zaW9ucztcbiAgLy8gVGhpcyBpcyBub3QgcHJpdmF0ZSBiZWNhdXNlIGl0J3MgdXNlZCBpbiB0aGUgU25hcCBjbGFzc1xuICB2aXJ0dWFsU2Nyb2xsO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgd3JhcHBlciA9IHdpbmRvdyxcbiAgICBjb250ZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgIGV2ZW50c1RhcmdldCA9IHdyYXBwZXIsXG4gICAgc21vb3RoV2hlZWwgPSB0cnVlLFxuICAgIHN5bmNUb3VjaCA9IGZhbHNlLFxuICAgIHN5bmNUb3VjaExlcnAgPSAwLjA3NSxcbiAgICB0b3VjaEluZXJ0aWFNdWx0aXBsaWVyID0gMzUsXG4gICAgZHVyYXRpb24sXG4gICAgLy8gaW4gc2Vjb25kc1xuICAgIGVhc2luZyA9ICh0KSA9PiBNYXRoLm1pbigxLCAxLjAwMSAtIE1hdGgucG93KDIsIC0xMCAqIHQpKSxcbiAgICBsZXJwOiBsZXJwMiA9IDAuMSxcbiAgICBpbmZpbml0ZSA9IGZhbHNlLFxuICAgIG9yaWVudGF0aW9uID0gXCJ2ZXJ0aWNhbFwiLFxuICAgIC8vIHZlcnRpY2FsLCBob3Jpem9udGFsXG4gICAgZ2VzdHVyZU9yaWVudGF0aW9uID0gXCJ2ZXJ0aWNhbFwiLFxuICAgIC8vIHZlcnRpY2FsLCBob3Jpem9udGFsLCBib3RoXG4gICAgdG91Y2hNdWx0aXBsaWVyID0gMSxcbiAgICB3aGVlbE11bHRpcGxpZXIgPSAxLFxuICAgIGF1dG9SZXNpemUgPSB0cnVlLFxuICAgIHByZXZlbnQsXG4gICAgdmlydHVhbFNjcm9sbCxcbiAgICBvdmVyc2Nyb2xsID0gdHJ1ZSxcbiAgICBhdXRvUmFmID0gZmFsc2UsXG4gICAgYW5jaG9ycyA9IGZhbHNlLFxuICAgIF9fZXhwZXJpbWVudGFsX19uYWl2ZURpbWVuc2lvbnMgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICB3aW5kb3cubGVuaXNWZXJzaW9uID0gdmVyc2lvbjtcbiAgICBpZiAoIXdyYXBwZXIgfHwgd3JhcHBlciA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICB3cmFwcGVyID0gd2luZG93O1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICB3cmFwcGVyLFxuICAgICAgY29udGVudCxcbiAgICAgIGV2ZW50c1RhcmdldCxcbiAgICAgIHNtb290aFdoZWVsLFxuICAgICAgc3luY1RvdWNoLFxuICAgICAgc3luY1RvdWNoTGVycCxcbiAgICAgIHRvdWNoSW5lcnRpYU11bHRpcGxpZXIsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGVhc2luZyxcbiAgICAgIGxlcnA6IGxlcnAyLFxuICAgICAgaW5maW5pdGUsXG4gICAgICBnZXN0dXJlT3JpZW50YXRpb24sXG4gICAgICBvcmllbnRhdGlvbixcbiAgICAgIHRvdWNoTXVsdGlwbGllcixcbiAgICAgIHdoZWVsTXVsdGlwbGllcixcbiAgICAgIGF1dG9SZXNpemUsXG4gICAgICBwcmV2ZW50LFxuICAgICAgdmlydHVhbFNjcm9sbCxcbiAgICAgIG92ZXJzY3JvbGwsXG4gICAgICBhdXRvUmFmLFxuICAgICAgYW5jaG9ycyxcbiAgICAgIF9fZXhwZXJpbWVudGFsX19uYWl2ZURpbWVuc2lvbnNcbiAgICB9O1xuICAgIHRoaXMuZGltZW5zaW9ucyA9IG5ldyBEaW1lbnNpb25zKHdyYXBwZXIsIGNvbnRlbnQsIHsgYXV0b1Jlc2l6ZSB9KTtcbiAgICB0aGlzLnVwZGF0ZUNsYXNzTmFtZSgpO1xuICAgIHRoaXMudGFyZ2V0U2Nyb2xsID0gdGhpcy5hbmltYXRlZFNjcm9sbCA9IHRoaXMuYWN0dWFsU2Nyb2xsO1xuICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vbk5hdGl2ZVNjcm9sbCwgZmFsc2UpO1xuICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxlbmRcIiwgdGhpcy5vblNjcm9sbEVuZCwge1xuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYW5jaG9ycyAmJiB0aGlzLm9wdGlvbnMud3JhcHBlciA9PT0gd2luZG93KSB7XG4gICAgICB0aGlzLm9wdGlvbnMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImNsaWNrXCIsXG4gICAgICAgIHRoaXMub25DbGljayxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcInBvaW50ZXJkb3duXCIsXG4gICAgICB0aGlzLm9uUG9pbnRlckRvd24sXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgdGhpcy52aXJ0dWFsU2Nyb2xsID0gbmV3IFZpcnR1YWxTY3JvbGwoZXZlbnRzVGFyZ2V0LCB7XG4gICAgICB0b3VjaE11bHRpcGxpZXIsXG4gICAgICB3aGVlbE11bHRpcGxpZXJcbiAgICB9KTtcbiAgICB0aGlzLnZpcnR1YWxTY3JvbGwub24oXCJzY3JvbGxcIiwgdGhpcy5vblZpcnR1YWxTY3JvbGwpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1JhZikge1xuICAgICAgdGhpcy5fX3JhZklEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIGxlbmlzIGluc3RhbmNlLCByZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVycyBhbmQgY2xlYW4gdXAgdGhlIGNsYXNzIG5hbWVcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbWl0dGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLm9wdGlvbnMud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgXCJzY3JvbGxcIixcbiAgICAgIHRoaXMub25OYXRpdmVTY3JvbGwsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgdGhpcy5vcHRpb25zLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbGVuZFwiLCB0aGlzLm9uU2Nyb2xsRW5kLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5vcHRpb25zLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwicG9pbnRlcmRvd25cIixcbiAgICAgIHRoaXMub25Qb2ludGVyRG93bixcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmFuY2hvcnMgJiYgdGhpcy5vcHRpb25zLndyYXBwZXIgPT09IHdpbmRvdykge1xuICAgICAgdGhpcy5vcHRpb25zLndyYXBwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJjbGlja1wiLFxuICAgICAgICB0aGlzLm9uQ2xpY2ssXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnZpcnR1YWxTY3JvbGwuZGVzdHJveSgpO1xuICAgIHRoaXMuZGltZW5zaW9ucy5kZXN0cm95KCk7XG4gICAgdGhpcy5jbGVhblVwQ2xhc3NOYW1lKCk7XG4gICAgaWYgKHRoaXMuX19yYWZJRCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fX3JhZklEKTtcbiAgICB9XG4gIH1cbiAgb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdHRlci5vbihldmVudCwgY2FsbGJhY2spO1xuICB9XG4gIG9mZihldmVudCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0dGVyLm9mZihldmVudCwgY2FsbGJhY2spO1xuICB9XG4gIG9uU2Nyb2xsRW5kID0gKGUpID0+IHtcbiAgICBpZiAoIShlIGluc3RhbmNlb2YgQ3VzdG9tRXZlbnQpKSB7XG4gICAgICBpZiAodGhpcy5pc1Njcm9sbGluZyA9PT0gXCJzbW9vdGhcIiB8fCB0aGlzLmlzU2Nyb2xsaW5nID09PSBmYWxzZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZGlzcGF0Y2hTY3JvbGxlbmRFdmVudCA9ICgpID0+IHtcbiAgICB0aGlzLm9wdGlvbnMud3JhcHBlci5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IEN1c3RvbUV2ZW50KFwic2Nyb2xsZW5kXCIsIHtcbiAgICAgICAgYnViYmxlczogdGhpcy5vcHRpb25zLndyYXBwZXIgPT09IHdpbmRvdyxcbiAgICAgICAgLy8gY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICAgIGRldGFpbDoge1xuICAgICAgICAgIGxlbmlzU2Nyb2xsRW5kOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcbiAgc2V0U2Nyb2xsKHNjcm9sbCkge1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xuICAgICAgdGhpcy5vcHRpb25zLndyYXBwZXIuc2Nyb2xsVG8oeyBsZWZ0OiBzY3JvbGwsIGJlaGF2aW9yOiBcImluc3RhbnRcIiB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcHRpb25zLndyYXBwZXIuc2Nyb2xsVG8oeyB0b3A6IHNjcm9sbCwgYmVoYXZpb3I6IFwiaW5zdGFudFwiIH0pO1xuICAgIH1cbiAgfVxuICBvbkNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgcGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICAgIGNvbnN0IGFuY2hvciA9IHBhdGguZmluZChcbiAgICAgIChub2RlKSA9PiBub2RlIGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpPy5zdGFydHNXaXRoKFwiI1wiKVxuICAgICk7XG4gICAgaWYgKGFuY2hvcikge1xuICAgICAgY29uc3QgaWQgPSBhbmNob3IuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICAgIGlmIChpZCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIHRoaXMub3B0aW9ucy5hbmNob3JzID09PSBcIm9iamVjdFwiICYmIHRoaXMub3B0aW9ucy5hbmNob3JzID8gdGhpcy5vcHRpb25zLmFuY2hvcnMgOiB2b2lkIDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG8oaWQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgb25Qb2ludGVyRG93biA9IChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5idXR0b24gPT09IDEpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gIH07XG4gIG9uVmlydHVhbFNjcm9sbCA9IChkYXRhKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMudmlydHVhbFNjcm9sbCA9PT0gXCJmdW5jdGlvblwiICYmIHRoaXMub3B0aW9ucy52aXJ0dWFsU2Nyb2xsKGRhdGEpID09PSBmYWxzZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGRlbHRhWCwgZGVsdGFZLCBldmVudCB9ID0gZGF0YTtcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdChcInZpcnR1YWwtc2Nyb2xsXCIsIHsgZGVsdGFYLCBkZWx0YVksIGV2ZW50IH0pO1xuICAgIGlmIChldmVudC5jdHJsS2V5KSByZXR1cm47XG4gICAgaWYgKGV2ZW50LmxlbmlzU3RvcFByb3BhZ2F0aW9uKSByZXR1cm47XG4gICAgY29uc3QgaXNUb3VjaCA9IGV2ZW50LnR5cGUuaW5jbHVkZXMoXCJ0b3VjaFwiKTtcbiAgICBjb25zdCBpc1doZWVsID0gZXZlbnQudHlwZS5pbmNsdWRlcyhcIndoZWVsXCIpO1xuICAgIHRoaXMuaXNUb3VjaGluZyA9IGV2ZW50LnR5cGUgPT09IFwidG91Y2hzdGFydFwiIHx8IGV2ZW50LnR5cGUgPT09IFwidG91Y2htb3ZlXCI7XG4gICAgY29uc3QgaXNDbGlja09yVGFwID0gZGVsdGFYID09PSAwICYmIGRlbHRhWSA9PT0gMDtcbiAgICBjb25zdCBpc1RhcFRvU3RvcCA9IHRoaXMub3B0aW9ucy5zeW5jVG91Y2ggJiYgaXNUb3VjaCAmJiBldmVudC50eXBlID09PSBcInRvdWNoc3RhcnRcIiAmJiBpc0NsaWNrT3JUYXAgJiYgIXRoaXMuaXNTdG9wcGVkICYmICF0aGlzLmlzTG9ja2VkO1xuICAgIGlmIChpc1RhcFRvU3RvcCkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc1Vua25vd25HZXN0dXJlID0gdGhpcy5vcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiICYmIGRlbHRhWSA9PT0gMCB8fCB0aGlzLm9wdGlvbnMuZ2VzdHVyZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiAmJiBkZWx0YVggPT09IDA7XG4gICAgaWYgKGlzQ2xpY2tPclRhcCB8fCBpc1Vua25vd25HZXN0dXJlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjb21wb3NlZFBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICBjb21wb3NlZFBhdGggPSBjb21wb3NlZFBhdGguc2xpY2UoMCwgY29tcG9zZWRQYXRoLmluZGV4T2YodGhpcy5yb290RWxlbWVudCkpO1xuICAgIGNvbnN0IHByZXZlbnQgPSB0aGlzLm9wdGlvbnMucHJldmVudDtcbiAgICBpZiAoISFjb21wb3NlZFBhdGguZmluZChcbiAgICAgIChub2RlKSA9PiBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgKHR5cGVvZiBwcmV2ZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgcHJldmVudD8uKG5vZGUpIHx8IG5vZGUuaGFzQXR0cmlidXRlPy4oXCJkYXRhLWxlbmlzLXByZXZlbnRcIikgfHwgaXNUb3VjaCAmJiBub2RlLmhhc0F0dHJpYnV0ZT8uKFwiZGF0YS1sZW5pcy1wcmV2ZW50LXRvdWNoXCIpIHx8IGlzV2hlZWwgJiYgbm9kZS5oYXNBdHRyaWJ1dGU/LihcImRhdGEtbGVuaXMtcHJldmVudC13aGVlbFwiKSlcbiAgICApKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLmlzU3RvcHBlZCB8fCB0aGlzLmlzTG9ja2VkKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc1Ntb290aCA9IHRoaXMub3B0aW9ucy5zeW5jVG91Y2ggJiYgaXNUb3VjaCB8fCB0aGlzLm9wdGlvbnMuc21vb3RoV2hlZWwgJiYgaXNXaGVlbDtcbiAgICBpZiAoIWlzU21vb3RoKSB7XG4gICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gXCJuYXRpdmVcIjtcbiAgICAgIHRoaXMuYW5pbWF0ZS5zdG9wKCk7XG4gICAgICBldmVudC5sZW5pc1N0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBkZWx0YSA9IGRlbHRhWTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbiA9PT0gXCJib3RoXCIpIHtcbiAgICAgIGRlbHRhID0gTWF0aC5hYnMoZGVsdGFZKSA+IE1hdGguYWJzKGRlbHRhWCkgPyBkZWx0YVkgOiBkZWx0YVg7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZ2VzdHVyZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgZGVsdGEgPSBkZWx0YVg7XG4gICAgfVxuICAgIGlmICghdGhpcy5vcHRpb25zLm92ZXJzY3JvbGwgfHwgdGhpcy5vcHRpb25zLmluZmluaXRlIHx8IHRoaXMub3B0aW9ucy53cmFwcGVyICE9PSB3aW5kb3cgJiYgKHRoaXMuYW5pbWF0ZWRTY3JvbGwgPiAwICYmIHRoaXMuYW5pbWF0ZWRTY3JvbGwgPCB0aGlzLmxpbWl0IHx8IHRoaXMuYW5pbWF0ZWRTY3JvbGwgPT09IDAgJiYgZGVsdGFZID4gMCB8fCB0aGlzLmFuaW1hdGVkU2Nyb2xsID09PSB0aGlzLmxpbWl0ICYmIGRlbHRhWSA8IDApKSB7XG4gICAgICBldmVudC5sZW5pc1N0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgaXNTeW5jVG91Y2ggPSBpc1RvdWNoICYmIHRoaXMub3B0aW9ucy5zeW5jVG91Y2g7XG4gICAgY29uc3QgaXNUb3VjaEVuZCA9IGlzVG91Y2ggJiYgZXZlbnQudHlwZSA9PT0gXCJ0b3VjaGVuZFwiO1xuICAgIGNvbnN0IGhhc1RvdWNoSW5lcnRpYSA9IGlzVG91Y2hFbmQgJiYgTWF0aC5hYnMoZGVsdGEpID4gNTtcbiAgICBpZiAoaGFzVG91Y2hJbmVydGlhKSB7XG4gICAgICBkZWx0YSA9IHRoaXMudmVsb2NpdHkgKiB0aGlzLm9wdGlvbnMudG91Y2hJbmVydGlhTXVsdGlwbGllcjtcbiAgICB9XG4gICAgdGhpcy5zY3JvbGxUbyh0aGlzLnRhcmdldFNjcm9sbCArIGRlbHRhLCB7XG4gICAgICBwcm9ncmFtbWF0aWM6IGZhbHNlLFxuICAgICAgLi4uaXNTeW5jVG91Y2ggPyB7XG4gICAgICAgIGxlcnA6IGhhc1RvdWNoSW5lcnRpYSA/IHRoaXMub3B0aW9ucy5zeW5jVG91Y2hMZXJwIDogMVxuICAgICAgICAvLyBpbW1lZGlhdGU6ICFoYXNUb3VjaEluZXJ0aWEsXG4gICAgICB9IDoge1xuICAgICAgICBsZXJwOiB0aGlzLm9wdGlvbnMubGVycCxcbiAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy5kdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiB0aGlzLm9wdGlvbnMuZWFzaW5nXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBGb3JjZSBsZW5pcyB0byByZWNhbGN1bGF0ZSB0aGUgZGltZW5zaW9uc1xuICAgKi9cbiAgcmVzaXplKCkge1xuICAgIHRoaXMuZGltZW5zaW9ucy5yZXNpemUoKTtcbiAgICB0aGlzLmFuaW1hdGVkU2Nyb2xsID0gdGhpcy50YXJnZXRTY3JvbGwgPSB0aGlzLmFjdHVhbFNjcm9sbDtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBlbWl0KCkge1xuICAgIHRoaXMuZW1pdHRlci5lbWl0KFwic2Nyb2xsXCIsIHRoaXMpO1xuICB9XG4gIG9uTmF0aXZlU2Nyb2xsID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLl9yZXNldFZlbG9jaXR5VGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Jlc2V0VmVsb2NpdHlUaW1lb3V0KTtcbiAgICAgIHRoaXMuX3Jlc2V0VmVsb2NpdHlUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3ByZXZlbnROZXh0TmF0aXZlU2Nyb2xsRXZlbnQpIHtcbiAgICAgIHRoaXMuX3ByZXZlbnROZXh0TmF0aXZlU2Nyb2xsRXZlbnQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTY3JvbGxpbmcgPT09IGZhbHNlIHx8IHRoaXMuaXNTY3JvbGxpbmcgPT09IFwibmF0aXZlXCIpIHtcbiAgICAgIGNvbnN0IGxhc3RTY3JvbGwgPSB0aGlzLmFuaW1hdGVkU2Nyb2xsO1xuICAgICAgdGhpcy5hbmltYXRlZFNjcm9sbCA9IHRoaXMudGFyZ2V0U2Nyb2xsID0gdGhpcy5hY3R1YWxTY3JvbGw7XG4gICAgICB0aGlzLmxhc3RWZWxvY2l0eSA9IHRoaXMudmVsb2NpdHk7XG4gICAgICB0aGlzLnZlbG9jaXR5ID0gdGhpcy5hbmltYXRlZFNjcm9sbCAtIGxhc3RTY3JvbGw7XG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IE1hdGguc2lnbihcbiAgICAgICAgdGhpcy5hbmltYXRlZFNjcm9sbCAtIGxhc3RTY3JvbGxcbiAgICAgICk7XG4gICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBcIm5hdGl2ZVwiO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCk7XG4gICAgICBpZiAodGhpcy52ZWxvY2l0eSAhPT0gMCkge1xuICAgICAgICB0aGlzLl9yZXNldFZlbG9jaXR5VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMubGFzdFZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eTtcbiAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gMDtcbiAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5lbWl0KCk7XG4gICAgICAgIH0sIDQwMCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXNldCgpIHtcbiAgICB0aGlzLmlzTG9ja2VkID0gZmFsc2U7XG4gICAgdGhpcy5pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuYW5pbWF0ZWRTY3JvbGwgPSB0aGlzLnRhcmdldFNjcm9sbCA9IHRoaXMuYWN0dWFsU2Nyb2xsO1xuICAgIHRoaXMubGFzdFZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eSA9IDA7XG4gICAgdGhpcy5hbmltYXRlLnN0b3AoKTtcbiAgfVxuICAvKipcbiAgICogU3RhcnQgbGVuaXMgc2Nyb2xsIGFmdGVyIGl0IGhhcyBiZWVuIHN0b3BwZWRcbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHJldHVybjtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogU3RvcCBsZW5pcyBzY3JvbGxcbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuaXNTdG9wcGVkKSByZXR1cm47XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZvciBsZW5pc1xuICAgKlxuICAgKiBAcGFyYW0gdGltZSBUaGUgdGltZSBpbiBtcyBmcm9tIGFuIGV4dGVybmFsIGNsb2NrIGxpa2UgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgb3IgVGVtcHVzXG4gICAqL1xuICByYWYgPSAodGltZSkgPT4ge1xuICAgIGNvbnN0IGRlbHRhVGltZSA9IHRpbWUgLSAodGhpcy50aW1lIHx8IHRpbWUpO1xuICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgdGhpcy5hbmltYXRlLmFkdmFuY2UoZGVsdGFUaW1lICogMWUtMyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUmFmKSB7XG4gICAgICB0aGlzLl9fcmFmSUQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yYWYpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFNjcm9sbCB0byBhIHRhcmdldCB2YWx1ZVxuICAgKlxuICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgdmFsdWUgdG8gc2Nyb2xsIHRvXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgc2Nyb2xsXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGxlbmlzLnNjcm9sbFRvKDEwMCwge1xuICAgKiAgIG9mZnNldDogMTAwLFxuICAgKiAgIGR1cmF0aW9uOiAxLFxuICAgKiAgIGVhc2luZzogKHQpID0+IDEgLSBNYXRoLmNvcygodCAqIE1hdGguUEkpIC8gMiksXG4gICAqICAgbGVycDogMC4xLFxuICAgKiAgIG9uU3RhcnQ6ICgpID0+IHtcbiAgICogICAgIGNvbnNvbGUubG9nKCdvblN0YXJ0JylcbiAgICogICB9LFxuICAgKiAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICogICAgIGNvbnNvbGUubG9nKCdvbkNvbXBsZXRlJylcbiAgICogICB9LFxuICAgKiB9KVxuICAgKi9cbiAgc2Nyb2xsVG8odGFyZ2V0LCB7XG4gICAgb2Zmc2V0ID0gMCxcbiAgICBpbW1lZGlhdGUgPSBmYWxzZSxcbiAgICBsb2NrID0gZmFsc2UsXG4gICAgZHVyYXRpb24gPSB0aGlzLm9wdGlvbnMuZHVyYXRpb24sXG4gICAgZWFzaW5nID0gdGhpcy5vcHRpb25zLmVhc2luZyxcbiAgICBsZXJwOiBsZXJwMiA9IHRoaXMub3B0aW9ucy5sZXJwLFxuICAgIG9uU3RhcnQsXG4gICAgb25Db21wbGV0ZSxcbiAgICBmb3JjZSA9IGZhbHNlLFxuICAgIC8vIHNjcm9sbCBldmVuIGlmIHN0b3BwZWRcbiAgICBwcm9ncmFtbWF0aWMgPSB0cnVlLFxuICAgIC8vIGNhbGxlZCBmcm9tIG91dHNpZGUgb2YgdGhlIGNsYXNzXG4gICAgdXNlckRhdGFcbiAgfSA9IHt9KSB7XG4gICAgaWYgKCh0aGlzLmlzU3RvcHBlZCB8fCB0aGlzLmlzTG9ja2VkKSAmJiAhZm9yY2UpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIiAmJiBbXCJ0b3BcIiwgXCJsZWZ0XCIsIFwic3RhcnRcIl0uaW5jbHVkZXModGFyZ2V0KSkge1xuICAgICAgdGFyZ2V0ID0gMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIgJiYgW1wiYm90dG9tXCIsIFwicmlnaHRcIiwgXCJlbmRcIl0uaW5jbHVkZXModGFyZ2V0KSkge1xuICAgICAgdGFyZ2V0ID0gdGhpcy5saW1pdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG5vZGU7XG4gICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBub2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICAgICAgfSBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiB0YXJnZXQ/Lm5vZGVUeXBlKSB7XG4gICAgICAgIG5vZGUgPSB0YXJnZXQ7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLndyYXBwZXIgIT09IHdpbmRvdykge1xuICAgICAgICAgIGNvbnN0IHdyYXBwZXJSZWN0ID0gdGhpcy5yb290RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBvZmZzZXQgLT0gdGhpcy5pc0hvcml6b250YWwgPyB3cmFwcGVyUmVjdC5sZWZ0IDogd3JhcHBlclJlY3QudG9wO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0YXJnZXQgPSAodGhpcy5pc0hvcml6b250YWwgPyByZWN0LmxlZnQgOiByZWN0LnRvcCkgKyB0aGlzLmFuaW1hdGVkU2Nyb2xsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gXCJudW1iZXJcIikgcmV0dXJuO1xuICAgIHRhcmdldCArPSBvZmZzZXQ7XG4gICAgdGFyZ2V0ID0gTWF0aC5yb3VuZCh0YXJnZXQpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuaW5maW5pdGUpIHtcbiAgICAgIGlmIChwcm9ncmFtbWF0aWMpIHtcbiAgICAgICAgdGhpcy50YXJnZXRTY3JvbGwgPSB0aGlzLmFuaW1hdGVkU2Nyb2xsID0gdGhpcy5zY3JvbGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldCA9IGNsYW1wKDAsIHRhcmdldCwgdGhpcy5saW1pdCk7XG4gICAgfVxuICAgIGlmICh0YXJnZXQgPT09IHRoaXMudGFyZ2V0U2Nyb2xsKSB7XG4gICAgICBvblN0YXJ0Py4odGhpcyk7XG4gICAgICBvbkNvbXBsZXRlPy4odGhpcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXNlckRhdGEgPSB1c2VyRGF0YSA/PyB7fTtcbiAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICB0aGlzLmFuaW1hdGVkU2Nyb2xsID0gdGhpcy50YXJnZXRTY3JvbGwgPSB0YXJnZXQ7XG4gICAgICB0aGlzLnNldFNjcm9sbCh0aGlzLnNjcm9sbCk7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB0aGlzLnByZXZlbnROZXh0TmF0aXZlU2Nyb2xsRXZlbnQoKTtcbiAgICAgIHRoaXMuZW1pdCgpO1xuICAgICAgb25Db21wbGV0ZT8uKHRoaXMpO1xuICAgICAgdGhpcy51c2VyRGF0YSA9IHt9O1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFNjcm9sbGVuZEV2ZW50KCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwcm9ncmFtbWF0aWMpIHtcbiAgICAgIHRoaXMudGFyZ2V0U2Nyb2xsID0gdGFyZ2V0O1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGUuZnJvbVRvKHRoaXMuYW5pbWF0ZWRTY3JvbGwsIHRhcmdldCwge1xuICAgICAgZHVyYXRpb24sXG4gICAgICBlYXNpbmcsXG4gICAgICBsZXJwOiBsZXJwMixcbiAgICAgIG9uU3RhcnQ6ICgpID0+IHtcbiAgICAgICAgaWYgKGxvY2spIHRoaXMuaXNMb2NrZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gXCJzbW9vdGhcIjtcbiAgICAgICAgb25TdGFydD8uKHRoaXMpO1xuICAgICAgfSxcbiAgICAgIG9uVXBkYXRlOiAodmFsdWUsIGNvbXBsZXRlZCkgPT4ge1xuICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gXCJzbW9vdGhcIjtcbiAgICAgICAgdGhpcy5sYXN0VmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5O1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdmFsdWUgLSB0aGlzLmFuaW1hdGVkU2Nyb2xsO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IE1hdGguc2lnbih0aGlzLnZlbG9jaXR5KTtcbiAgICAgICAgdGhpcy5hbmltYXRlZFNjcm9sbCA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNldFNjcm9sbCh0aGlzLnNjcm9sbCk7XG4gICAgICAgIGlmIChwcm9ncmFtbWF0aWMpIHtcbiAgICAgICAgICB0aGlzLnRhcmdldFNjcm9sbCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29tcGxldGVkKSB0aGlzLmVtaXQoKTtcbiAgICAgICAgaWYgKGNvbXBsZXRlZCkge1xuICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICB0aGlzLmVtaXQoKTtcbiAgICAgICAgICBvbkNvbXBsZXRlPy4odGhpcyk7XG4gICAgICAgICAgdGhpcy51c2VyRGF0YSA9IHt9O1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoU2Nyb2xsZW5kRXZlbnQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnByZXZlbnROZXh0TmF0aXZlU2Nyb2xsRXZlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHByZXZlbnROZXh0TmF0aXZlU2Nyb2xsRXZlbnQoKSB7XG4gICAgdGhpcy5fcHJldmVudE5leHROYXRpdmVTY3JvbGxFdmVudCA9IHRydWU7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuX3ByZXZlbnROZXh0TmF0aXZlU2Nyb2xsRXZlbnQgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhlIHJvb3QgZWxlbWVudCBvbiB3aGljaCBsZW5pcyBpcyBpbnN0YW5jZWRcbiAgICovXG4gIGdldCByb290RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLndyYXBwZXIgPT09IHdpbmRvdyA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IHRoaXMub3B0aW9ucy53cmFwcGVyO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbGltaXQgd2hpY2ggaXMgdGhlIG1heGltdW0gc2Nyb2xsIHZhbHVlXG4gICAqL1xuICBnZXQgbGltaXQoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5fX2V4cGVyaW1lbnRhbF9fbmFpdmVEaW1lbnNpb25zKSB7XG4gICAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdEVsZW1lbnQuc2Nyb2xsV2lkdGggLSB0aGlzLnJvb3RFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gdGhpcy5yb290RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbnMubGltaXRbdGhpcy5pc0hvcml6b250YWwgPyBcInhcIiA6IFwieVwiXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSBzY3JvbGwgaXMgaG9yaXpvbnRhbFxuICAgKi9cbiAgZ2V0IGlzSG9yaXpvbnRhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIjtcbiAgfVxuICAvKipcbiAgICogVGhlIGFjdHVhbCBzY3JvbGwgdmFsdWVcbiAgICovXG4gIGdldCBhY3R1YWxTY3JvbGwoKSB7XG4gICAgY29uc3Qgd3JhcHBlciA9IHRoaXMub3B0aW9ucy53cmFwcGVyO1xuICAgIHJldHVybiB0aGlzLmlzSG9yaXpvbnRhbCA/IHdyYXBwZXIuc2Nyb2xsWCA/PyB3cmFwcGVyLnNjcm9sbExlZnQgOiB3cmFwcGVyLnNjcm9sbFkgPz8gd3JhcHBlci5zY3JvbGxUb3A7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHNjcm9sbCB2YWx1ZVxuICAgKi9cbiAgZ2V0IHNjcm9sbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmluZmluaXRlID8gbW9kdWxvKHRoaXMuYW5pbWF0ZWRTY3JvbGwsIHRoaXMubGltaXQpIDogdGhpcy5hbmltYXRlZFNjcm9sbDtcbiAgfVxuICAvKipcbiAgICogVGhlIHByb2dyZXNzIG9mIHRoZSBzY3JvbGwgcmVsYXRpdmUgdG8gdGhlIGxpbWl0XG4gICAqL1xuICBnZXQgcHJvZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMubGltaXQgPT09IDAgPyAxIDogdGhpcy5zY3JvbGwgLyB0aGlzLmxpbWl0O1xuICB9XG4gIC8qKlxuICAgKiBDdXJyZW50IHNjcm9sbCBzdGF0ZVxuICAgKi9cbiAgZ2V0IGlzU2Nyb2xsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Njcm9sbGluZztcbiAgfVxuICBzZXQgaXNTY3JvbGxpbmcodmFsdWUpIHtcbiAgICBpZiAodGhpcy5faXNTY3JvbGxpbmcgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9pc1Njcm9sbGluZyA9IHZhbHVlO1xuICAgICAgdGhpcy51cGRhdGVDbGFzc05hbWUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGxlbmlzIGlzIHN0b3BwZWRcbiAgICovXG4gIGdldCBpc1N0b3BwZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RvcHBlZDtcbiAgfVxuICBzZXQgaXNTdG9wcGVkKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2lzU3RvcHBlZCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2lzU3RvcHBlZCA9IHZhbHVlO1xuICAgICAgdGhpcy51cGRhdGVDbGFzc05hbWUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGxlbmlzIGlzIGxvY2tlZFxuICAgKi9cbiAgZ2V0IGlzTG9ja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0xvY2tlZDtcbiAgfVxuICBzZXQgaXNMb2NrZWQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5faXNMb2NrZWQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9pc0xvY2tlZCA9IHZhbHVlO1xuICAgICAgdGhpcy51cGRhdGVDbGFzc05hbWUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGxlbmlzIGlzIHNtb290aCBzY3JvbGxpbmdcbiAgICovXG4gIGdldCBpc1Ntb290aCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1Njcm9sbGluZyA9PT0gXCJzbW9vdGhcIjtcbiAgfVxuICAvKipcbiAgICogVGhlIGNsYXNzIG5hbWUgYXBwbGllZCB0byB0aGUgd3JhcHBlciBlbGVtZW50XG4gICAqL1xuICBnZXQgY2xhc3NOYW1lKCkge1xuICAgIGxldCBjbGFzc05hbWUgPSBcImxlbmlzXCI7XG4gICAgaWYgKHRoaXMuaXNTdG9wcGVkKSBjbGFzc05hbWUgKz0gXCIgbGVuaXMtc3RvcHBlZFwiO1xuICAgIGlmICh0aGlzLmlzTG9ja2VkKSBjbGFzc05hbWUgKz0gXCIgbGVuaXMtbG9ja2VkXCI7XG4gICAgaWYgKHRoaXMuaXNTY3JvbGxpbmcpIGNsYXNzTmFtZSArPSBcIiBsZW5pcy1zY3JvbGxpbmdcIjtcbiAgICBpZiAodGhpcy5pc1Njcm9sbGluZyA9PT0gXCJzbW9vdGhcIikgY2xhc3NOYW1lICs9IFwiIGxlbmlzLXNtb290aFwiO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cbiAgdXBkYXRlQ2xhc3NOYW1lKCkge1xuICAgIHRoaXMuY2xlYW5VcENsYXNzTmFtZSgpO1xuICAgIHRoaXMucm9vdEVsZW1lbnQuY2xhc3NOYW1lID0gYCR7dGhpcy5yb290RWxlbWVudC5jbGFzc05hbWV9ICR7dGhpcy5jbGFzc05hbWV9YC50cmltKCk7XG4gIH1cbiAgY2xlYW5VcENsYXNzTmFtZSgpIHtcbiAgICB0aGlzLnJvb3RFbGVtZW50LmNsYXNzTmFtZSA9IHRoaXMucm9vdEVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoL2xlbmlzKC1cXHcrKT8vZywgXCJcIikudHJpbSgpO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgTGVuaXMgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlbmlzLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/lenis/dist/lenis.mjs\n");

/***/ })

};
;